/* File generated by the BNF Converter (bnfc 2.9.4). */

#ifndef __JLC_LLVM_GENERATOR__
#define __JLC_LLVM_GENERATOR__
/* You might want to change the above name. */
#include <iostream>

#include "Absyn.H"
#include "context.H"

#include "Skeleton.H"

// llvm dependencies
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/Value.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Type.h"

#define LLVM_ERROR_HANDLE(msg)                      \
	while (1)                                       \
	{                                               \
		std::cerr << "Error: " << msg << std::endl; \
		LLVM_module_->print(llvm::outs(), nullptr); \
		exit(1);                                    \
	}

class JLCLLVMGenerator : public Skeleton
{
public:
	JLCContext globalContext;
	JLCType temp_type;
	op_enum temp_op;

	JLCLLVMGenerator() : LLVM_Context_(std::make_unique<llvm::LLVMContext>()),
						 LLVM_module_(std::make_unique<llvm::Module>("JLC_llvm", *LLVM_Context_)),
						 LLVM_builder_(std::make_unique<llvm::IRBuilder<>>(*LLVM_Context_))
	{
		addExternalFunc();
	};

	~JLCLLVMGenerator()
	{
		LLVM_module_->print(llvm::outs(), nullptr);
	};
	// std::vector<std::string> global_declear_segment;

private:
	/* serving for generating llvm code*/
	std::unique_ptr<llvm::LLVMContext> LLVM_Context_;
	std::unique_ptr<llvm::Module> LLVM_module_;
	std::unique_ptr<llvm::IRBuilder<>> LLVM_builder_;

	llvm::Value *llvm_temp_value_;

	bool left_value_flag = false;

	// for saving the type of the array
	// @TODO: there should be a better way to store the array type,
	//  like using getTypeByName of llvm api.
	std::map<std::string, llvm::Type *> array_type_map;

	llvm::Type *DefineAndGetArrayType(JLCType type);

	// for saving the block of the value
	// @TODO: there are should be a better way to do this
	std::map<std::string, llvm::BasicBlock *> value_block_map_;

	void setLLVMTempValue(llvm::Value *value)
	{
		llvm_temp_value_ = value;
		// add the block of the value to the map
		value_block_map_[std::string(value->getName())] = LLVM_builder_->GetInsertBlock();
	}

	llvm::BasicBlock *getBlockOfValue(llvm::Value *&value)
	{
		if (value_block_map_.find(std::string(value->getName())) != value_block_map_.end())
		{
			return value_block_map_[std::string(value->getName())];
		}
		// should not reach here
		LLVM_ERROR_HANDLE("block of value not found");
		return nullptr;
	}

	// for saving the variable in the block, the last element is the current block
	// mapping from original variable name to llvm variable
	std::vector<std::map<std::string, llvm::Value *>> block_var_map_list;

	void addBlockVarMap()
	{
		block_var_map_list.push_back(std::map<std::string, llvm::Value *>());
	}

	void removeBlockVarMap()
	{
		block_var_map_list.pop_back();
	}

	void addVarToBlockMap(std::string var_name, llvm::Value *var_value)
	{
		block_var_map_list.back()[var_name] = var_value;
	}

	llvm::Value *getVarFromBlockMap(std::string var_name)
	{
		for (int i = block_var_map_list.size() - 1; i >= 0; i--)
		{
			if (block_var_map_list[i].find(var_name) != block_var_map_list[i].end())
			{
				return block_var_map_list[i][var_name];
			}
		}
		// it should not reach here
		LLVM_ERROR_HANDLE("variable " + var_name + " not found in llvm block name map");
		return nullptr;
	}

	// type conversion
	llvm::Type *convertType(JLCType type);
	// add inner/external function to the head of the ll file
	// for example, printInt, printDouble, printString, printBool
	void addExternalFunc();

	void addFuncDeclearation(JLCFunc &frame);

public:

	void visitProgram(Program *p);
	void visitFnDef(FnDef *p);
	void visitArgument(Argument *p);
	void visitBlock(Block *p);
	// void visitEmpty(Empty *p);
	void visitBStmt(BStmt *p);
	void visitDecl(Decl *p);
	void visitNoInit(NoInit *p);
	void visitInit(Init *p);
	void visitAss(Ass *p);
	void visitIncr(Incr *p);
	void visitDecr(Decr *p);
	void visitRet(Ret *p);
	void visitVRet(VRet *p);
	void visitCond(Cond *p);
	void visitCondElse(CondElse *p);
	void visitWhile(While *p);
	void visitSExp(SExp *p);
	void visitInt(Int *p);
	void visitDoub(Doub *p);
	void visitBool(Bool *p);
	void visitVoid(Void *p);
	void visitFun(Fun *p);
	void visitEVar(EVar *p);
	void visitELitInt(ELitInt *p);
	void visitELitDoub(ELitDoub *p);
	void visitELitTrue(ELitTrue *p);
	void visitELitFalse(ELitFalse *p);
	void visitEApp(EApp *p);
	void visitEString(EString *p);
	void visitNeg(Neg *p);
	void visitNot(Not *p);
	void visitEMul(EMul *p);
	void visitEAdd(EAdd *p);
	void visitERel(ERel *p);
	void visitEAnd(EAnd *p);
	void visitEOr(EOr *p);
	void visitPlus(Plus *p);
	void visitMinus(Minus *p);
	void visitTimes(Times *p);
	void visitDiv(Div *p);
	void visitMod(Mod *p);
	void visitLTH(LTH *p);
	void visitLE(LE *p);
	void visitGTH(GTH *p);
	void visitGE(GE *p);
	void visitEQU(EQU *p);
	void visitNE(NE *p);
	// void visitListTopDef(ListTopDef *p);
	// void visitListArg(ListArg *p);
	// void visitListStmt(ListStmt *p);
	// void visitListItem(ListItem *p);
	// void visitListType(ListType *p);
	// void visitListExpr(ListExpr *p);

	// void visitInteger(Integer x);
	// void visitChar(Char x);
	// void visitDouble(Double x);
	// void visitString(String x);
	// void visitIdent(Ident x);

	// for array
	// void visitBracketsOpt(BracketsOpt *p);
	// void visitDimExpr(DimExpr *p);
	void visitAssArr(AssArr *p);
	void visitArrayType(ArrayType *p);
	// void visitBracketsEmpty(BracketsEmpty *p);
	void visitENewArray(ENewArray *p);
	void visitDim(Dim *p);
	void visitEDot(EDot *p);
	void visitEAcc(EAcc *p);
	// void visitListBracketsOpt(ListBracketsOpt *p);
	// void visitListDimExpr(ListDimExpr *p);
	void visitForLoop(ForLoop *p);
};

#endif
