/* File generated by the BNF Converter (bnfc 2.9.4). */

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class Prog;
class TopDef;
class Arg;
class Blk;
class Stmt;
class Item;
class SStmt;
class Type;
class BracketsOpt;
class Expr;
class DimExpr;
class AddOp;
class MulOp;
class RelOp;
class MAccOp;
class Program;
class TypeDef;
class StructDef;
class FnDef;
class FnDefS;
class Argument;
class Ptrgument;
class Block;
class Empty;
class BStmt;
class Decl;
class DeclObjPtr;
class NoInit;
class Init;
class Ass;
class AssArr;
class Incr;
class Decr;
class Ret;
class VRet;
class Cond;
class CondElse;
class While;
class ForLoop;
class ForStruct;
class SExp;
class MInner;
class MArray;
class MSArray;
class MStruct;
class Int;
class Doub;
class Bool;
class Void;
class Fun;
class ArrayType;
class SArrayType;
class BracketsEmpty;
class ENewArray;
class ENewSArray;
class Dim;
class EDot;
class EAcc;
class ENewStruct;
class EMember;
class TypeCast;
class ELitInt;
class ELitDoub;
class ELitTrue;
class ELitFalse;
class EString;
class EVar;
class EApp;
class Neg;
class Not;
class EMul;
class EAdd;
class ERel;
class EAnd;
class EOr;
class Plus;
class Minus;
class Times;
class Div;
class Mod;
class LTH;
class LE;
class GTH;
class GE;
class EQU;
class NE;
class MAcc;
class ListTopDef;
class ListArg;
class ListStmt;
class ListItem;
class ListSStmt;
class ListType;
class ListBracketsOpt;
class ListDimExpr;
class ListExpr;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitProg(Prog *p) = 0;
  virtual void visitTopDef(TopDef *p) = 0;
  virtual void visitArg(Arg *p) = 0;
  virtual void visitBlk(Blk *p) = 0;
  virtual void visitStmt(Stmt *p) = 0;
  virtual void visitItem(Item *p) = 0;
  virtual void visitSStmt(SStmt *p) = 0;
  virtual void visitType(Type *p) = 0;
  virtual void visitBracketsOpt(BracketsOpt *p) = 0;
  virtual void visitExpr(Expr *p) = 0;
  virtual void visitDimExpr(DimExpr *p) = 0;
  virtual void visitAddOp(AddOp *p) = 0;
  virtual void visitMulOp(MulOp *p) = 0;
  virtual void visitRelOp(RelOp *p) = 0;
  virtual void visitMAccOp(MAccOp *p) = 0;
  virtual void visitProgram(Program *p) = 0;
  virtual void visitTypeDef(TypeDef *p) = 0;
  virtual void visitStructDef(StructDef *p) = 0;
  virtual void visitFnDef(FnDef *p) = 0;
  virtual void visitFnDefS(FnDefS *p) = 0;
  virtual void visitArgument(Argument *p) = 0;
  virtual void visitPtrgument(Ptrgument *p) = 0;
  virtual void visitBlock(Block *p) = 0;
  virtual void visitEmpty(Empty *p) = 0;
  virtual void visitBStmt(BStmt *p) = 0;
  virtual void visitDecl(Decl *p) = 0;
  virtual void visitDeclObjPtr(DeclObjPtr *p) = 0;
  virtual void visitNoInit(NoInit *p) = 0;
  virtual void visitInit(Init *p) = 0;
  virtual void visitAss(Ass *p) = 0;
  virtual void visitAssArr(AssArr *p) = 0;
  virtual void visitIncr(Incr *p) = 0;
  virtual void visitDecr(Decr *p) = 0;
  virtual void visitRet(Ret *p) = 0;
  virtual void visitVRet(VRet *p) = 0;
  virtual void visitCond(Cond *p) = 0;
  virtual void visitCondElse(CondElse *p) = 0;
  virtual void visitWhile(While *p) = 0;
  virtual void visitForLoop(ForLoop *p) = 0;
  virtual void visitForStruct(ForStruct *p) = 0;
  virtual void visitSExp(SExp *p) = 0;
  virtual void visitMInner(MInner *p) = 0;
  virtual void visitMArray(MArray *p) = 0;
  virtual void visitMSArray(MSArray *p) = 0;
  virtual void visitMStruct(MStruct *p) = 0;
  virtual void visitInt(Int *p) = 0;
  virtual void visitDoub(Doub *p) = 0;
  virtual void visitBool(Bool *p) = 0;
  virtual void visitVoid(Void *p) = 0;
  virtual void visitFun(Fun *p) = 0;
  virtual void visitArrayType(ArrayType *p) = 0;
  virtual void visitSArrayType(SArrayType *p) = 0;
  virtual void visitBracketsEmpty(BracketsEmpty *p) = 0;
  virtual void visitENewArray(ENewArray *p) = 0;
  virtual void visitENewSArray(ENewSArray *p) = 0;
  virtual void visitDim(Dim *p) = 0;
  virtual void visitEDot(EDot *p) = 0;
  virtual void visitEAcc(EAcc *p) = 0;
  virtual void visitENewStruct(ENewStruct *p) = 0;
  virtual void visitEMember(EMember *p) = 0;
  virtual void visitTypeCast(TypeCast *p) = 0;
  virtual void visitELitInt(ELitInt *p) = 0;
  virtual void visitELitDoub(ELitDoub *p) = 0;
  virtual void visitELitTrue(ELitTrue *p) = 0;
  virtual void visitELitFalse(ELitFalse *p) = 0;
  virtual void visitEString(EString *p) = 0;
  virtual void visitEVar(EVar *p) = 0;
  virtual void visitEApp(EApp *p) = 0;
  virtual void visitNeg(Neg *p) = 0;
  virtual void visitNot(Not *p) = 0;
  virtual void visitEMul(EMul *p) = 0;
  virtual void visitEAdd(EAdd *p) = 0;
  virtual void visitERel(ERel *p) = 0;
  virtual void visitEAnd(EAnd *p) = 0;
  virtual void visitEOr(EOr *p) = 0;
  virtual void visitPlus(Plus *p) = 0;
  virtual void visitMinus(Minus *p) = 0;
  virtual void visitTimes(Times *p) = 0;
  virtual void visitDiv(Div *p) = 0;
  virtual void visitMod(Mod *p) = 0;
  virtual void visitLTH(LTH *p) = 0;
  virtual void visitLE(LE *p) = 0;
  virtual void visitGTH(GTH *p) = 0;
  virtual void visitGE(GE *p) = 0;
  virtual void visitEQU(EQU *p) = 0;
  virtual void visitNE(NE *p) = 0;
  virtual void visitMAcc(MAcc *p) = 0;
  virtual void visitListTopDef(ListTopDef *p) = 0;
  virtual void visitListArg(ListArg *p) = 0;
  virtual void visitListStmt(ListStmt *p) = 0;
  virtual void visitListItem(ListItem *p) = 0;
  virtual void visitListSStmt(ListSStmt *p) = 0;
  virtual void visitListType(ListType *p) = 0;
  virtual void visitListBracketsOpt(ListBracketsOpt *p) = 0;
  virtual void visitListDimExpr(ListDimExpr *p) = 0;
  virtual void visitListExpr(ListExpr *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Prog : public Visitable
{
public:
  virtual Prog *clone() const = 0;

};

class TopDef : public Visitable
{
public:
  virtual TopDef *clone() const = 0;

};

class Arg : public Visitable
{
public:
  virtual Arg *clone() const = 0;

};

class Blk : public Visitable
{
public:
  virtual Blk *clone() const = 0;

};

class Stmt : public Visitable
{
public:
  virtual Stmt *clone() const = 0;

};

class Item : public Visitable
{
public:
  virtual Item *clone() const = 0;

};

class SStmt : public Visitable
{
public:
  virtual SStmt *clone() const = 0;

};

class Type : public Visitable
{
public:
  virtual Type *clone() const = 0;

};

class BracketsOpt : public Visitable
{
public:
  virtual BracketsOpt *clone() const = 0;

};

class Expr : public Visitable
{
public:
  virtual Expr *clone() const = 0;

};

class DimExpr : public Visitable
{
public:
  virtual DimExpr *clone() const = 0;

};

class AddOp : public Visitable
{
public:
  virtual AddOp *clone() const = 0;

};

class MulOp : public Visitable
{
public:
  virtual MulOp *clone() const = 0;

};

class RelOp : public Visitable
{
public:
  virtual RelOp *clone() const = 0;

};

class MAccOp : public Visitable
{
public:
  virtual MAccOp *clone() const = 0;

};



class Program : public Prog
{
public:
  ListTopDef *listtopdef_;

  Program(const Program &);
  Program &operator=(const Program &);
  Program(ListTopDef *p1);
  ~Program();
  virtual void accept(Visitor *v);
  virtual Program *clone() const;
  void swap(Program &);
};

class TypeDef : public TopDef
{
public:
  Ident ident_1;
  Ident ident_2;

  TypeDef(const TypeDef &);
  TypeDef &operator=(const TypeDef &);
  TypeDef(Ident p1, Ident p2);
  ~TypeDef();
  virtual void accept(Visitor *v);
  virtual TypeDef *clone() const;
  void swap(TypeDef &);
};

class StructDef : public TopDef
{
public:
  Ident ident_;
  ListSStmt *listsstmt_;

  StructDef(const StructDef &);
  StructDef &operator=(const StructDef &);
  StructDef(Ident p1, ListSStmt *p2);
  ~StructDef();
  virtual void accept(Visitor *v);
  virtual StructDef *clone() const;
  void swap(StructDef &);
};

class FnDef : public TopDef
{
public:
  Type *type_;
  Ident ident_;
  ListArg *listarg_;
  Blk *blk_;

  FnDef(const FnDef &);
  FnDef &operator=(const FnDef &);
  FnDef(Type *p1, Ident p2, ListArg *p3, Blk *p4);
  ~FnDef();
  virtual void accept(Visitor *v);
  virtual FnDef *clone() const;
  void swap(FnDef &);
};

class FnDefS : public TopDef
{
public:
  Ident ident_1;
  Ident ident_2;
  ListArg *listarg_;
  Blk *blk_;

  FnDefS(const FnDefS &);
  FnDefS &operator=(const FnDefS &);
  FnDefS(Ident p1, Ident p2, ListArg *p3, Blk *p4);
  ~FnDefS();
  virtual void accept(Visitor *v);
  virtual FnDefS *clone() const;
  void swap(FnDefS &);
};

class Argument : public Arg
{
public:
  Type *type_;
  Ident ident_;

  Argument(const Argument &);
  Argument &operator=(const Argument &);
  Argument(Type *p1, Ident p2);
  ~Argument();
  virtual void accept(Visitor *v);
  virtual Argument *clone() const;
  void swap(Argument &);
};

class Ptrgument : public Arg
{
public:
  Ident ident_1;
  Ident ident_2;

  Ptrgument(const Ptrgument &);
  Ptrgument &operator=(const Ptrgument &);
  Ptrgument(Ident p1, Ident p2);
  ~Ptrgument();
  virtual void accept(Visitor *v);
  virtual Ptrgument *clone() const;
  void swap(Ptrgument &);
};

class Block : public Blk
{
public:
  ListStmt *liststmt_;

  Block(const Block &);
  Block &operator=(const Block &);
  Block(ListStmt *p1);
  ~Block();
  virtual void accept(Visitor *v);
  virtual Block *clone() const;
  void swap(Block &);
};

class Empty : public Stmt
{
public:

  Empty(const Empty &);
  Empty &operator=(const Empty &);
  Empty();
  ~Empty();
  virtual void accept(Visitor *v);
  virtual Empty *clone() const;
  void swap(Empty &);
};

class BStmt : public Stmt
{
public:
  Blk *blk_;

  BStmt(const BStmt &);
  BStmt &operator=(const BStmt &);
  BStmt(Blk *p1);
  ~BStmt();
  virtual void accept(Visitor *v);
  virtual BStmt *clone() const;
  void swap(BStmt &);
};

class Decl : public Stmt
{
public:
  Type *type_;
  ListItem *listitem_;

  Decl(const Decl &);
  Decl &operator=(const Decl &);
  Decl(Type *p1, ListItem *p2);
  ~Decl();
  virtual void accept(Visitor *v);
  virtual Decl *clone() const;
  void swap(Decl &);
};

class DeclObjPtr : public Stmt
{
public:
  Ident ident_;
  ListItem *listitem_;

  DeclObjPtr(const DeclObjPtr &);
  DeclObjPtr &operator=(const DeclObjPtr &);
  DeclObjPtr(Ident p1, ListItem *p2);
  ~DeclObjPtr();
  virtual void accept(Visitor *v);
  virtual DeclObjPtr *clone() const;
  void swap(DeclObjPtr &);
};

class Ass : public Stmt
{
public:
  Ident ident_;
  Expr *expr_;

  Ass(const Ass &);
  Ass &operator=(const Ass &);
  Ass(Ident p1, Expr *p2);
  ~Ass();
  virtual void accept(Visitor *v);
  virtual Ass *clone() const;
  void swap(Ass &);
};

class AssArr : public Stmt
{
public:
  Expr *expr_1;
  Expr *expr_2;

  AssArr(const AssArr &);
  AssArr &operator=(const AssArr &);
  AssArr(Expr *p1, Expr *p2);
  ~AssArr();
  virtual void accept(Visitor *v);
  virtual AssArr *clone() const;
  void swap(AssArr &);
};

class Incr : public Stmt
{
public:
  Ident ident_;

  Incr(const Incr &);
  Incr &operator=(const Incr &);
  Incr(Ident p1);
  ~Incr();
  virtual void accept(Visitor *v);
  virtual Incr *clone() const;
  void swap(Incr &);
};

class Decr : public Stmt
{
public:
  Ident ident_;

  Decr(const Decr &);
  Decr &operator=(const Decr &);
  Decr(Ident p1);
  ~Decr();
  virtual void accept(Visitor *v);
  virtual Decr *clone() const;
  void swap(Decr &);
};

class Ret : public Stmt
{
public:
  Expr *expr_;

  Ret(const Ret &);
  Ret &operator=(const Ret &);
  Ret(Expr *p1);
  ~Ret();
  virtual void accept(Visitor *v);
  virtual Ret *clone() const;
  void swap(Ret &);
};

class VRet : public Stmt
{
public:

  VRet(const VRet &);
  VRet &operator=(const VRet &);
  VRet();
  ~VRet();
  virtual void accept(Visitor *v);
  virtual VRet *clone() const;
  void swap(VRet &);
};

class Cond : public Stmt
{
public:
  Expr *expr_;
  Stmt *stmt_;

  Cond(const Cond &);
  Cond &operator=(const Cond &);
  Cond(Expr *p1, Stmt *p2);
  ~Cond();
  virtual void accept(Visitor *v);
  virtual Cond *clone() const;
  void swap(Cond &);
};

class CondElse : public Stmt
{
public:
  Expr *expr_;
  Stmt *stmt_1;
  Stmt *stmt_2;

  CondElse(const CondElse &);
  CondElse &operator=(const CondElse &);
  CondElse(Expr *p1, Stmt *p2, Stmt *p3);
  ~CondElse();
  virtual void accept(Visitor *v);
  virtual CondElse *clone() const;
  void swap(CondElse &);
};

class While : public Stmt
{
public:
  Expr *expr_;
  Stmt *stmt_;

  While(const While &);
  While &operator=(const While &);
  While(Expr *p1, Stmt *p2);
  ~While();
  virtual void accept(Visitor *v);
  virtual While *clone() const;
  void swap(While &);
};

class ForLoop : public Stmt
{
public:
  Type *type_;
  Ident ident_;
  Expr *expr_;
  Stmt *stmt_;

  ForLoop(const ForLoop &);
  ForLoop &operator=(const ForLoop &);
  ForLoop(Type *p1, Ident p2, Expr *p3, Stmt *p4);
  ~ForLoop();
  virtual void accept(Visitor *v);
  virtual ForLoop *clone() const;
  void swap(ForLoop &);
};

class ForStruct : public Stmt
{
public:
  Ident ident_1;
  Ident ident_2;
  Expr *expr_;
  Stmt *stmt_;

  ForStruct(const ForStruct &);
  ForStruct &operator=(const ForStruct &);
  ForStruct(Ident p1, Ident p2, Expr *p3, Stmt *p4);
  ~ForStruct();
  virtual void accept(Visitor *v);
  virtual ForStruct *clone() const;
  void swap(ForStruct &);
};

class SExp : public Stmt
{
public:
  Expr *expr_;

  SExp(const SExp &);
  SExp &operator=(const SExp &);
  SExp(Expr *p1);
  ~SExp();
  virtual void accept(Visitor *v);
  virtual SExp *clone() const;
  void swap(SExp &);
};

class NoInit : public Item
{
public:
  Ident ident_;

  NoInit(const NoInit &);
  NoInit &operator=(const NoInit &);
  NoInit(Ident p1);
  ~NoInit();
  virtual void accept(Visitor *v);
  virtual NoInit *clone() const;
  void swap(NoInit &);
};

class Init : public Item
{
public:
  Ident ident_;
  Expr *expr_;

  Init(const Init &);
  Init &operator=(const Init &);
  Init(Ident p1, Expr *p2);
  ~Init();
  virtual void accept(Visitor *v);
  virtual Init *clone() const;
  void swap(Init &);
};

class MInner : public SStmt
{
public:
  Type *type_;
  Ident ident_;

  MInner(const MInner &);
  MInner &operator=(const MInner &);
  MInner(Type *p1, Ident p2);
  ~MInner();
  virtual void accept(Visitor *v);
  virtual MInner *clone() const;
  void swap(MInner &);
};

class MArray : public SStmt
{
public:
  Type *type_;
  ListBracketsOpt *listbracketsopt_;
  Ident ident_;

  MArray(const MArray &);
  MArray &operator=(const MArray &);
  MArray(Type *p1, ListBracketsOpt *p2, Ident p3);
  ~MArray();
  virtual void accept(Visitor *v);
  virtual MArray *clone() const;
  void swap(MArray &);
};

class MSArray : public SStmt
{
public:
  Ident ident_1;
  ListBracketsOpt *listbracketsopt_;
  Ident ident_2;

  MSArray(const MSArray &);
  MSArray &operator=(const MSArray &);
  MSArray(Ident p1, ListBracketsOpt *p2, Ident p3);
  ~MSArray();
  virtual void accept(Visitor *v);
  virtual MSArray *clone() const;
  void swap(MSArray &);
};

class MStruct : public SStmt
{
public:
  Ident ident_1;
  Ident ident_2;

  MStruct(const MStruct &);
  MStruct &operator=(const MStruct &);
  MStruct(Ident p1, Ident p2);
  ~MStruct();
  virtual void accept(Visitor *v);
  virtual MStruct *clone() const;
  void swap(MStruct &);
};

class Int : public Type
{
public:

  Int(const Int &);
  Int &operator=(const Int &);
  Int();
  ~Int();
  virtual void accept(Visitor *v);
  virtual Int *clone() const;
  void swap(Int &);
};

class Doub : public Type
{
public:

  Doub(const Doub &);
  Doub &operator=(const Doub &);
  Doub();
  ~Doub();
  virtual void accept(Visitor *v);
  virtual Doub *clone() const;
  void swap(Doub &);
};

class Bool : public Type
{
public:

  Bool(const Bool &);
  Bool &operator=(const Bool &);
  Bool();
  ~Bool();
  virtual void accept(Visitor *v);
  virtual Bool *clone() const;
  void swap(Bool &);
};

class Void : public Type
{
public:

  Void(const Void &);
  Void &operator=(const Void &);
  Void();
  ~Void();
  virtual void accept(Visitor *v);
  virtual Void *clone() const;
  void swap(Void &);
};

class Fun : public Type
{
public:
  Type *type_;
  ListType *listtype_;

  Fun(const Fun &);
  Fun &operator=(const Fun &);
  Fun(Type *p1, ListType *p2);
  ~Fun();
  virtual void accept(Visitor *v);
  virtual Fun *clone() const;
  void swap(Fun &);
};

class ArrayType : public Type
{
public:
  Type *type_;
  ListBracketsOpt *listbracketsopt_;

  ArrayType(const ArrayType &);
  ArrayType &operator=(const ArrayType &);
  ArrayType(Type *p1, ListBracketsOpt *p2);
  ~ArrayType();
  virtual void accept(Visitor *v);
  virtual ArrayType *clone() const;
  void swap(ArrayType &);
};

class SArrayType : public Type
{
public:
  Ident ident_;
  ListBracketsOpt *listbracketsopt_;

  SArrayType(const SArrayType &);
  SArrayType &operator=(const SArrayType &);
  SArrayType(Ident p1, ListBracketsOpt *p2);
  ~SArrayType();
  virtual void accept(Visitor *v);
  virtual SArrayType *clone() const;
  void swap(SArrayType &);
};

class BracketsEmpty : public BracketsOpt
{
public:

  BracketsEmpty(const BracketsEmpty &);
  BracketsEmpty &operator=(const BracketsEmpty &);
  BracketsEmpty();
  ~BracketsEmpty();
  virtual void accept(Visitor *v);
  virtual BracketsEmpty *clone() const;
  void swap(BracketsEmpty &);
};

class ENewArray : public Expr
{
public:
  Type *type_;
  ListDimExpr *listdimexpr_;

  ENewArray(const ENewArray &);
  ENewArray &operator=(const ENewArray &);
  ENewArray(Type *p1, ListDimExpr *p2);
  ~ENewArray();
  virtual void accept(Visitor *v);
  virtual ENewArray *clone() const;
  void swap(ENewArray &);
};

class ENewSArray : public Expr
{
public:
  Ident ident_;
  ListDimExpr *listdimexpr_;

  ENewSArray(const ENewSArray &);
  ENewSArray &operator=(const ENewSArray &);
  ENewSArray(Ident p1, ListDimExpr *p2);
  ~ENewSArray();
  virtual void accept(Visitor *v);
  virtual ENewSArray *clone() const;
  void swap(ENewSArray &);
};

class EDot : public Expr
{
public:
  Expr *expr_;
  Ident ident_;

  EDot(const EDot &);
  EDot &operator=(const EDot &);
  EDot(Expr *p1, Ident p2);
  ~EDot();
  virtual void accept(Visitor *v);
  virtual EDot *clone() const;
  void swap(EDot &);
};

class EAcc : public Expr
{
public:
  Expr *expr_;
  ListDimExpr *listdimexpr_;

  EAcc(const EAcc &);
  EAcc &operator=(const EAcc &);
  EAcc(Expr *p1, ListDimExpr *p2);
  ~EAcc();
  virtual void accept(Visitor *v);
  virtual EAcc *clone() const;
  void swap(EAcc &);
};

class ENewStruct : public Expr
{
public:
  Ident ident_;

  ENewStruct(const ENewStruct &);
  ENewStruct &operator=(const ENewStruct &);
  ENewStruct(Ident p1);
  ~ENewStruct();
  virtual void accept(Visitor *v);
  virtual ENewStruct *clone() const;
  void swap(ENewStruct &);
};

class EMember : public Expr
{
public:
  Expr *expr_;
  MAccOp *maccop_;
  Ident ident_;

  EMember(const EMember &);
  EMember &operator=(const EMember &);
  EMember(Expr *p1, MAccOp *p2, Ident p3);
  ~EMember();
  virtual void accept(Visitor *v);
  virtual EMember *clone() const;
  void swap(EMember &);
};

class TypeCast : public Expr
{
public:
  Ident ident_;

  TypeCast(const TypeCast &);
  TypeCast &operator=(const TypeCast &);
  TypeCast(Ident p1);
  ~TypeCast();
  virtual void accept(Visitor *v);
  virtual TypeCast *clone() const;
  void swap(TypeCast &);
};

class ELitInt : public Expr
{
public:
  Integer integer_;

  ELitInt(const ELitInt &);
  ELitInt &operator=(const ELitInt &);
  ELitInt(Integer p1);
  ~ELitInt();
  virtual void accept(Visitor *v);
  virtual ELitInt *clone() const;
  void swap(ELitInt &);
};

class ELitDoub : public Expr
{
public:
  Double double_;

  ELitDoub(const ELitDoub &);
  ELitDoub &operator=(const ELitDoub &);
  ELitDoub(Double p1);
  ~ELitDoub();
  virtual void accept(Visitor *v);
  virtual ELitDoub *clone() const;
  void swap(ELitDoub &);
};

class ELitTrue : public Expr
{
public:

  ELitTrue(const ELitTrue &);
  ELitTrue &operator=(const ELitTrue &);
  ELitTrue();
  ~ELitTrue();
  virtual void accept(Visitor *v);
  virtual ELitTrue *clone() const;
  void swap(ELitTrue &);
};

class ELitFalse : public Expr
{
public:

  ELitFalse(const ELitFalse &);
  ELitFalse &operator=(const ELitFalse &);
  ELitFalse();
  ~ELitFalse();
  virtual void accept(Visitor *v);
  virtual ELitFalse *clone() const;
  void swap(ELitFalse &);
};

class EString : public Expr
{
public:
  String string_;

  EString(const EString &);
  EString &operator=(const EString &);
  EString(String p1);
  ~EString();
  virtual void accept(Visitor *v);
  virtual EString *clone() const;
  void swap(EString &);
};

class EVar : public Expr
{
public:
  Ident ident_;

  EVar(const EVar &);
  EVar &operator=(const EVar &);
  EVar(Ident p1);
  ~EVar();
  virtual void accept(Visitor *v);
  virtual EVar *clone() const;
  void swap(EVar &);
};

class EApp : public Expr
{
public:
  Ident ident_;
  ListExpr *listexpr_;

  EApp(const EApp &);
  EApp &operator=(const EApp &);
  EApp(Ident p1, ListExpr *p2);
  ~EApp();
  virtual void accept(Visitor *v);
  virtual EApp *clone() const;
  void swap(EApp &);
};

class Neg : public Expr
{
public:
  Expr *expr_;

  Neg(const Neg &);
  Neg &operator=(const Neg &);
  Neg(Expr *p1);
  ~Neg();
  virtual void accept(Visitor *v);
  virtual Neg *clone() const;
  void swap(Neg &);
};

class Not : public Expr
{
public:
  Expr *expr_;

  Not(const Not &);
  Not &operator=(const Not &);
  Not(Expr *p1);
  ~Not();
  virtual void accept(Visitor *v);
  virtual Not *clone() const;
  void swap(Not &);
};

class EMul : public Expr
{
public:
  Expr *expr_1;
  MulOp *mulop_;
  Expr *expr_2;

  EMul(const EMul &);
  EMul &operator=(const EMul &);
  EMul(Expr *p1, MulOp *p2, Expr *p3);
  ~EMul();
  virtual void accept(Visitor *v);
  virtual EMul *clone() const;
  void swap(EMul &);
};

class EAdd : public Expr
{
public:
  Expr *expr_1;
  AddOp *addop_;
  Expr *expr_2;

  EAdd(const EAdd &);
  EAdd &operator=(const EAdd &);
  EAdd(Expr *p1, AddOp *p2, Expr *p3);
  ~EAdd();
  virtual void accept(Visitor *v);
  virtual EAdd *clone() const;
  void swap(EAdd &);
};

class ERel : public Expr
{
public:
  Expr *expr_1;
  RelOp *relop_;
  Expr *expr_2;

  ERel(const ERel &);
  ERel &operator=(const ERel &);
  ERel(Expr *p1, RelOp *p2, Expr *p3);
  ~ERel();
  virtual void accept(Visitor *v);
  virtual ERel *clone() const;
  void swap(ERel &);
};

class EAnd : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  EAnd(const EAnd &);
  EAnd &operator=(const EAnd &);
  EAnd(Expr *p1, Expr *p2);
  ~EAnd();
  virtual void accept(Visitor *v);
  virtual EAnd *clone() const;
  void swap(EAnd &);
};

class EOr : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  EOr(const EOr &);
  EOr &operator=(const EOr &);
  EOr(Expr *p1, Expr *p2);
  ~EOr();
  virtual void accept(Visitor *v);
  virtual EOr *clone() const;
  void swap(EOr &);
};

class Dim : public DimExpr
{
public:
  Expr *expr_;

  Dim(const Dim &);
  Dim &operator=(const Dim &);
  Dim(Expr *p1);
  ~Dim();
  virtual void accept(Visitor *v);
  virtual Dim *clone() const;
  void swap(Dim &);
};

class Plus : public AddOp
{
public:

  Plus(const Plus &);
  Plus &operator=(const Plus &);
  Plus();
  ~Plus();
  virtual void accept(Visitor *v);
  virtual Plus *clone() const;
  void swap(Plus &);
};

class Minus : public AddOp
{
public:

  Minus(const Minus &);
  Minus &operator=(const Minus &);
  Minus();
  ~Minus();
  virtual void accept(Visitor *v);
  virtual Minus *clone() const;
  void swap(Minus &);
};

class Times : public MulOp
{
public:

  Times(const Times &);
  Times &operator=(const Times &);
  Times();
  ~Times();
  virtual void accept(Visitor *v);
  virtual Times *clone() const;
  void swap(Times &);
};

class Div : public MulOp
{
public:

  Div(const Div &);
  Div &operator=(const Div &);
  Div();
  ~Div();
  virtual void accept(Visitor *v);
  virtual Div *clone() const;
  void swap(Div &);
};

class Mod : public MulOp
{
public:

  Mod(const Mod &);
  Mod &operator=(const Mod &);
  Mod();
  ~Mod();
  virtual void accept(Visitor *v);
  virtual Mod *clone() const;
  void swap(Mod &);
};

class LTH : public RelOp
{
public:

  LTH(const LTH &);
  LTH &operator=(const LTH &);
  LTH();
  ~LTH();
  virtual void accept(Visitor *v);
  virtual LTH *clone() const;
  void swap(LTH &);
};

class LE : public RelOp
{
public:

  LE(const LE &);
  LE &operator=(const LE &);
  LE();
  ~LE();
  virtual void accept(Visitor *v);
  virtual LE *clone() const;
  void swap(LE &);
};

class GTH : public RelOp
{
public:

  GTH(const GTH &);
  GTH &operator=(const GTH &);
  GTH();
  ~GTH();
  virtual void accept(Visitor *v);
  virtual GTH *clone() const;
  void swap(GTH &);
};

class GE : public RelOp
{
public:

  GE(const GE &);
  GE &operator=(const GE &);
  GE();
  ~GE();
  virtual void accept(Visitor *v);
  virtual GE *clone() const;
  void swap(GE &);
};

class EQU : public RelOp
{
public:

  EQU(const EQU &);
  EQU &operator=(const EQU &);
  EQU();
  ~EQU();
  virtual void accept(Visitor *v);
  virtual EQU *clone() const;
  void swap(EQU &);
};

class NE : public RelOp
{
public:

  NE(const NE &);
  NE &operator=(const NE &);
  NE();
  ~NE();
  virtual void accept(Visitor *v);
  virtual NE *clone() const;
  void swap(NE &);
};

class MAcc : public MAccOp
{
public:

  MAcc(const MAcc &);
  MAcc &operator=(const MAcc &);
  MAcc();
  ~MAcc();
  virtual void accept(Visitor *v);
  virtual MAcc *clone() const;
  void swap(MAcc &);
};



class ListTopDef : public Visitable, public std::vector<TopDef*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListTopDef *clone() const;
};

ListTopDef* consListTopDef(TopDef* x, ListTopDef* xs);

class ListArg : public Visitable, public std::vector<Arg*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListArg *clone() const;
};

ListArg* consListArg(Arg* x, ListArg* xs);

class ListStmt : public Visitable, public std::vector<Stmt*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListStmt *clone() const;
};

ListStmt* consListStmt(Stmt* x, ListStmt* xs);

class ListItem : public Visitable, public std::vector<Item*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListItem *clone() const;
};

ListItem* consListItem(Item* x, ListItem* xs);

class ListSStmt : public Visitable, public std::vector<SStmt*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListSStmt *clone() const;
};

ListSStmt* consListSStmt(SStmt* x, ListSStmt* xs);

class ListType : public Visitable, public std::vector<Type*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListType *clone() const;
};

ListType* consListType(Type* x, ListType* xs);

class ListBracketsOpt : public Visitable, public std::vector<BracketsOpt*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListBracketsOpt *clone() const;
};

ListBracketsOpt* consListBracketsOpt(BracketsOpt* x, ListBracketsOpt* xs);

class ListDimExpr : public Visitable, public std::vector<DimExpr*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListDimExpr *clone() const;
};

ListDimExpr* consListDimExpr(DimExpr* x, ListDimExpr* xs);

class ListExpr : public Visitable, public std::vector<Expr*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExpr *clone() const;
};

ListExpr* consListExpr(Expr* x, ListExpr* xs);





#endif
