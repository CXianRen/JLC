/* File generated by the BNF Converter (bnfc 2.9.4). */

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

/* strdup was not in the ISO C standard before 6/2019 (C2x), but in POSIX 1003.1.
 * See: https://en.cppreference.com/w/c/experimental/dynamic/strdup
 * Setting _POSIX_C_SOURCE to 200809L activates strdup in string.h.
 */
#define _POSIX_C_SOURCE 200809L

#include <stddef.h>  /* NULL */
#include <string.h>  /* strdup */

/* C++ Abstract Syntax Interface.*/

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;

/********************   Forward Declarations    ***********************/
struct Prog_;
typedef struct Prog_ *Prog;

struct TopDef_;
typedef struct TopDef_ *TopDef;

struct ListTopDef_;
typedef struct ListTopDef_ *ListTopDef;

struct Arg_;
typedef struct Arg_ *Arg;

struct ListArg_;
typedef struct ListArg_ *ListArg;

struct Blk_;
typedef struct Blk_ *Blk;

struct ListStmt_;
typedef struct ListStmt_ *ListStmt;

struct Stmt_;
typedef struct Stmt_ *Stmt;

struct Item_;
typedef struct Item_ *Item;

struct ListItem_;
typedef struct ListItem_ *ListItem;

struct Type_;
typedef struct Type_ *Type;

struct ListType_;
typedef struct ListType_ *ListType;

struct Expr_;
typedef struct Expr_ *Expr;

struct ListExpr_;
typedef struct ListExpr_ *ListExpr;

struct AddOp_;
typedef struct AddOp_ *AddOp;

struct MulOp_;
typedef struct MulOp_ *MulOp;

struct RelOp_;
typedef struct RelOp_ *RelOp;

/********************   Abstract Syntax Classes    ********************/

struct Prog_
{
  enum { is_Program } kind;
  union
  {
    struct { ListTopDef listtopdef_; } program_;
  } u;
};

Prog make_Program(ListTopDef p0);

struct TopDef_
{
  enum { is_FnDef } kind;
  union
  {
    struct { Blk blk_; Ident ident_; ListArg listarg_; Type type_; } fndef_;
  } u;
};

TopDef make_FnDef(Type p0, Ident p1, ListArg p2, Blk p3);

struct ListTopDef_
{
  TopDef topdef_;
  ListTopDef listtopdef_;
};

ListTopDef make_ListTopDef(TopDef p1, ListTopDef p2);

struct Arg_
{
  enum { is_Argument } kind;
  union
  {
    struct { Ident ident_; Type type_; } argument_;
  } u;
};

Arg make_Argument(Type p0, Ident p1);

struct ListArg_
{
  Arg arg_;
  ListArg listarg_;
};

ListArg make_ListArg(Arg p1, ListArg p2);

struct Blk_
{
  enum { is_Block } kind;
  union
  {
    struct { ListStmt liststmt_; } block_;
  } u;
};

Blk make_Block(ListStmt p0);

struct ListStmt_
{
  Stmt stmt_;
  ListStmt liststmt_;
};

ListStmt make_ListStmt(Stmt p1, ListStmt p2);

struct Stmt_
{
  enum { is_Empty, is_BStmt, is_Decl, is_Ass, is_Incr, is_Decr, is_Ret, is_VRet, is_Cond, is_CondElse, is_While, is_SExp } kind;
  union
  {
    struct { Blk blk_; } bstmt_;
    struct { ListItem listitem_; Type type_; } decl_;
    struct { Expr expr_; Ident ident_; } ass_;
    struct { Ident ident_; } incr_;
    struct { Ident ident_; } decr_;
    struct { Expr expr_; } ret_;
    struct { Expr expr_; Stmt stmt_; } cond_;
    struct { Expr expr_; Stmt stmt_1, stmt_2; } condelse_;
    struct { Expr expr_; Stmt stmt_; } while_;
    struct { Expr expr_; } sexp_;
  } u;
};

Stmt make_Empty(void);
Stmt make_BStmt(Blk p0);
Stmt make_Decl(Type p0, ListItem p1);
Stmt make_Ass(Ident p0, Expr p1);
Stmt make_Incr(Ident p0);
Stmt make_Decr(Ident p0);
Stmt make_Ret(Expr p0);
Stmt make_VRet(void);
Stmt make_Cond(Expr p0, Stmt p1);
Stmt make_CondElse(Expr p0, Stmt p1, Stmt p2);
Stmt make_While(Expr p0, Stmt p1);
Stmt make_SExp(Expr p0);

struct Item_
{
  enum { is_NoInit, is_Init } kind;
  union
  {
    struct { Ident ident_; } noinit_;
    struct { Expr expr_; Ident ident_; } init_;
  } u;
};

Item make_NoInit(Ident p0);
Item make_Init(Ident p0, Expr p1);

struct ListItem_
{
  Item item_;
  ListItem listitem_;
};

ListItem make_ListItem(Item p1, ListItem p2);

struct Type_
{
  enum { is_Int, is_Doub, is_Bool, is_Void, is_Fun } kind;
  union
  {
    struct { ListType listtype_; Type type_; } fun_;
  } u;
};

Type make_Int(void);
Type make_Doub(void);
Type make_Bool(void);
Type make_Void(void);
Type make_Fun(Type p0, ListType p1);

struct ListType_
{
  Type type_;
  ListType listtype_;
};

ListType make_ListType(Type p1, ListType p2);

struct Expr_
{
  enum { is_EVar, is_ELitInt, is_ELitDoub, is_ELitTrue, is_ELitFalse, is_EApp, is_EString, is_Neg, is_Not, is_EMul, is_EAdd, is_ERel, is_EAnd, is_EOr } kind;
  union
  {
    struct { Ident ident_; } evar_;
    struct { Integer integer_; } elitint_;
    struct { Double double_; } elitdoub_;
    struct { Ident ident_; ListExpr listexpr_; } eapp_;
    struct { String string_; } estring_;
    struct { Expr expr_; } neg_;
    struct { Expr expr_; } not_;
    struct { Expr expr_1, expr_2; MulOp mulop_; } emul_;
    struct { AddOp addop_; Expr expr_1, expr_2; } eadd_;
    struct { Expr expr_1, expr_2; RelOp relop_; } erel_;
    struct { Expr expr_1, expr_2; } eand_;
    struct { Expr expr_1, expr_2; } eor_;
  } u;
};

Expr make_EVar(Ident p0);
Expr make_ELitInt(Integer p0);
Expr make_ELitDoub(Double p0);
Expr make_ELitTrue(void);
Expr make_ELitFalse(void);
Expr make_EApp(Ident p0, ListExpr p1);
Expr make_EString(String p0);
Expr make_Neg(Expr p0);
Expr make_Not(Expr p0);
Expr make_EMul(Expr p0, MulOp p1, Expr p2);
Expr make_EAdd(Expr p0, AddOp p1, Expr p2);
Expr make_ERel(Expr p0, RelOp p1, Expr p2);
Expr make_EAnd(Expr p0, Expr p1);
Expr make_EOr(Expr p0, Expr p1);

struct ListExpr_
{
  Expr expr_;
  ListExpr listexpr_;
};

ListExpr make_ListExpr(Expr p1, ListExpr p2);

struct AddOp_
{
  enum { is_Plus, is_Minus } kind;
  union
  {
  } u;
};

AddOp make_Plus(void);
AddOp make_Minus(void);

struct MulOp_
{
  enum { is_Times, is_Div, is_Mod } kind;
  union
  {
  } u;
};

MulOp make_Times(void);
MulOp make_Div(void);
MulOp make_Mod(void);

struct RelOp_
{
  enum { is_LTH, is_LE, is_GTH, is_GE, is_EQU, is_NE } kind;
  union
  {
  } u;
};

RelOp make_LTH(void);
RelOp make_LE(void);
RelOp make_GTH(void);
RelOp make_GE(void);
RelOp make_EQU(void);
RelOp make_NE(void);

/***************************   Cloning   ******************************/

Prog clone_Prog(Prog p);
TopDef clone_TopDef(TopDef p);
ListTopDef clone_ListTopDef(ListTopDef p);
Arg clone_Arg(Arg p);
ListArg clone_ListArg(ListArg p);
Blk clone_Blk(Blk p);
ListStmt clone_ListStmt(ListStmt p);
Stmt clone_Stmt(Stmt p);
Item clone_Item(Item p);
ListItem clone_ListItem(ListItem p);
Type clone_Type(Type p);
ListType clone_ListType(ListType p);
Expr clone_Expr(Expr p);
ListExpr clone_ListExpr(ListExpr p);
AddOp clone_AddOp(AddOp p);
MulOp clone_MulOp(MulOp p);
RelOp clone_RelOp(RelOp p);

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Prog(Prog p);
void free_TopDef(TopDef p);
void free_ListTopDef(ListTopDef p);
void free_Arg(Arg p);
void free_ListArg(ListArg p);
void free_Blk(Blk p);
void free_ListStmt(ListStmt p);
void free_Stmt(Stmt p);
void free_Item(Item p);
void free_ListItem(ListItem p);
void free_Type(Type p);
void free_ListType(ListType p);
void free_Expr(Expr p);
void free_ListExpr(ListExpr p);
void free_AddOp(AddOp p);
void free_MulOp(MulOp p);
void free_RelOp(RelOp p);


#endif
