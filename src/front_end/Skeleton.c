/* File generated by the BNF Converter (bnfc 2.9.4). */

/*** Visitor Traversal Skeleton. ***/
/* This traverses the abstract syntax tree.
   To use, copy Skeleton.h and Skeleton.c to
   new files. */

#include <stdlib.h>
#include <stdio.h>

#include "Skeleton.h"

void visitProg(Prog p)
{
  switch(p->kind)
  {
  case is_Program:
    /* Code for Program Goes Here */
    visitListTopDef(p->u.program_.listtopdef_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing Prog!\n");
    exit(1);
  }
}

void visitTopDef(TopDef p)
{
  switch(p->kind)
  {
  case is_FnDef:
    /* Code for FnDef Goes Here */
    visitType(p->u.fndef_.type_);
    visitIdent(p->u.fndef_.ident_);
    visitListArg(p->u.fndef_.listarg_);
    visitBlk(p->u.fndef_.blk_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing TopDef!\n");
    exit(1);
  }
}

void visitListTopDef(ListTopDef listtopdef)
{
  while(listtopdef  != 0)
  {
    /* Code For ListTopDef Goes Here */
    visitTopDef(listtopdef->topdef_);
    listtopdef = listtopdef->listtopdef_;
  }
}

void visitArg(Arg p)
{
  switch(p->kind)
  {
  case is_Argument:
    /* Code for Argument Goes Here */
    visitType(p->u.argument_.type_);
    visitIdent(p->u.argument_.ident_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing Arg!\n");
    exit(1);
  }
}

void visitListArg(ListArg listarg)
{
  while(listarg  != 0)
  {
    /* Code For ListArg Goes Here */
    visitArg(listarg->arg_);
    listarg = listarg->listarg_;
  }
}

void visitBlk(Blk p)
{
  switch(p->kind)
  {
  case is_Block:
    /* Code for Block Goes Here */
    visitListStmt(p->u.block_.liststmt_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing Blk!\n");
    exit(1);
  }
}

void visitListStmt(ListStmt liststmt)
{
  while(liststmt  != 0)
  {
    /* Code For ListStmt Goes Here */
    visitStmt(liststmt->stmt_);
    liststmt = liststmt->liststmt_;
  }
}

void visitStmt(Stmt p)
{
  switch(p->kind)
  {
  case is_Empty:
    /* Code for Empty Goes Here */
    break;
  case is_BStmt:
    /* Code for BStmt Goes Here */
    visitBlk(p->u.bstmt_.blk_);
    break;
  case is_Decl:
    /* Code for Decl Goes Here */
    visitType(p->u.decl_.type_);
    visitListItem(p->u.decl_.listitem_);
    break;
  case is_Ass:
    /* Code for Ass Goes Here */
    visitIdent(p->u.ass_.ident_);
    visitExpr(p->u.ass_.expr_);
    break;
  case is_Incr:
    /* Code for Incr Goes Here */
    visitIdent(p->u.incr_.ident_);
    break;
  case is_Decr:
    /* Code for Decr Goes Here */
    visitIdent(p->u.decr_.ident_);
    break;
  case is_Ret:
    /* Code for Ret Goes Here */
    visitExpr(p->u.ret_.expr_);
    break;
  case is_VRet:
    /* Code for VRet Goes Here */
    break;
  case is_Cond:
    /* Code for Cond Goes Here */
    visitExpr(p->u.cond_.expr_);
    visitStmt(p->u.cond_.stmt_);
    break;
  case is_CondElse:
    /* Code for CondElse Goes Here */
    visitExpr(p->u.condelse_.expr_);
    visitStmt(p->u.condelse_.stmt_1);
    visitStmt(p->u.condelse_.stmt_2);
    break;
  case is_While:
    /* Code for While Goes Here */
    visitExpr(p->u.while_.expr_);
    visitStmt(p->u.while_.stmt_);
    break;
  case is_SExp:
    /* Code for SExp Goes Here */
    visitExpr(p->u.sexp_.expr_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing Stmt!\n");
    exit(1);
  }
}

void visitItem(Item p)
{
  switch(p->kind)
  {
  case is_NoInit:
    /* Code for NoInit Goes Here */
    visitIdent(p->u.noinit_.ident_);
    break;
  case is_Init:
    /* Code for Init Goes Here */
    visitIdent(p->u.init_.ident_);
    visitExpr(p->u.init_.expr_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing Item!\n");
    exit(1);
  }
}

void visitListItem(ListItem listitem)
{
  while(listitem  != 0)
  {
    /* Code For ListItem Goes Here */
    visitItem(listitem->item_);
    listitem = listitem->listitem_;
  }
}

void visitType(Type p)
{
  switch(p->kind)
  {
  case is_Int:
    /* Code for Int Goes Here */
    break;
  case is_Doub:
    /* Code for Doub Goes Here */
    break;
  case is_Bool:
    /* Code for Bool Goes Here */
    break;
  case is_Void:
    /* Code for Void Goes Here */
    break;
  case is_Fun:
    /* Code for Fun Goes Here */
    visitType(p->u.fun_.type_);
    visitListType(p->u.fun_.listtype_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing Type!\n");
    exit(1);
  }
}

void visitListType(ListType listtype)
{
  while(listtype  != 0)
  {
    /* Code For ListType Goes Here */
    visitType(listtype->type_);
    listtype = listtype->listtype_;
  }
}

void visitExpr(Expr p)
{
  switch(p->kind)
  {
  case is_EVar:
    /* Code for EVar Goes Here */
    visitIdent(p->u.evar_.ident_);
    break;
  case is_ELitInt:
    /* Code for ELitInt Goes Here */
    visitInteger(p->u.elitint_.integer_);
    break;
  case is_ELitDoub:
    /* Code for ELitDoub Goes Here */
    visitDouble(p->u.elitdoub_.double_);
    break;
  case is_ELitTrue:
    /* Code for ELitTrue Goes Here */
    break;
  case is_ELitFalse:
    /* Code for ELitFalse Goes Here */
    break;
  case is_EApp:
    /* Code for EApp Goes Here */
    visitIdent(p->u.eapp_.ident_);
    visitListExpr(p->u.eapp_.listexpr_);
    break;
  case is_EString:
    /* Code for EString Goes Here */
    visitString(p->u.estring_.string_);
    break;
  case is_Neg:
    /* Code for Neg Goes Here */
    visitExpr(p->u.neg_.expr_);
    break;
  case is_Not:
    /* Code for Not Goes Here */
    visitExpr(p->u.not_.expr_);
    break;
  case is_EMul:
    /* Code for EMul Goes Here */
 
    visitExpr(p->u.emul_.expr_1);
    visitMulOp(p->u.emul_.mulop_);
    visitExpr(p->u.emul_.expr_2);
    if(p->u.emul_.expr_1->kind == p->u.emul_.expr_2->kind) break;
    else {
      fprintf(stderr, "Error: type cant match\n");
      exit(1);
    }
  case is_EAdd:
    /* Code for EAdd Goes Here */
    visitExpr(p->u.eadd_.expr_1);
    visitAddOp(p->u.eadd_.addop_);
    visitExpr(p->u.eadd_.expr_2);
    break;
  case is_ERel:
    /* Code for ERel Goes Here */
    visitExpr(p->u.erel_.expr_1);
    visitRelOp(p->u.erel_.relop_);
    visitExpr(p->u.erel_.expr_2);
    break;
  case is_EAnd:
    /* Code for EAnd Goes Here */
    visitExpr(p->u.eand_.expr_1);
    visitExpr(p->u.eand_.expr_2);
    break;
  case is_EOr:
    /* Code for EOr Goes Here */
    visitExpr(p->u.eor_.expr_1);
    visitExpr(p->u.eor_.expr_2);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing Expr!\n");
    exit(1);
  }
}

void visitListExpr(ListExpr listexpr)
{
  while(listexpr  != 0)
  {
    /* Code For ListExpr Goes Here */
    visitExpr(listexpr->expr_);
    listexpr = listexpr->listexpr_;
  }
}

void visitAddOp(AddOp p)
{
  switch(p->kind)
  {
  case is_Plus:
    /* Code for Plus Goes Here */
    break;
  case is_Minus:
    /* Code for Minus Goes Here */
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing AddOp!\n");
    exit(1);
  }
}

void visitMulOp(MulOp p)
{
  switch(p->kind)
  {
  case is_Times:
    /* Code for Times Goes Here */
    break;
  case is_Div:
    /* Code for Div Goes Here */
    break;
  case is_Mod:
    /* Code for Mod Goes Here */
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing MulOp!\n");
    exit(1);
  }
}

void visitRelOp(RelOp p)
{
  switch(p->kind)
  {
  case is_LTH:
    /* Code for LTH Goes Here */
    break;
  case is_LE:
    /* Code for LE Goes Here */
    break;
  case is_GTH:
    /* Code for GTH Goes Here */
    break;
  case is_GE:
    /* Code for GE Goes Here */
    break;
  case is_EQU:
    /* Code for EQU Goes Here */
    break;
  case is_NE:
    /* Code for NE Goes Here */
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing RelOp!\n");
    exit(1);
  }
}

void visitIdent(Ident i)
{
  /* Code for Ident Goes Here */
}
void visitInteger(Integer i)
{
  /* Code for Integer Goes Here */
}
void visitDouble(Double d)
{
  /* Code for Double Goes Here */
}
void visitChar(Char c)
{
  /* Code for Char Goes Here */
}
void visitString(String s)
{
  /* Code for String Goes Here */
}

