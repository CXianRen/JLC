/* File generated by the BNF Converter (bnfc 2.9.4). */

/*** Visitor Design Pattern JLCVariableCommonChecker. ***/
/* This implements the common visitor design pattern.
   Note that this method uses Visitor-traversal of lists, so
   List->accept() does NOT traverse the list. This allows different
   algorithms to use context information differently. */

#include "JLCChecker.H"
#include "context.H"
#include "util.h"
#include "Printer.H"

#include <iostream>
#include <string>
#include <cstdlib>

static type_enum temp_type;
static std::string temp_ident;
static std::string temp_exp_type = "DEFAULT";

static bool isCheckFunction = false;
static std::string fuctionName;

static PrintAbsyn p = PrintAbsyn();

static const std::string checkerName = "JLCVariableCommonChecker";

void JLCVariableCommonChecker::visitProg(Prog *t) {} //abstract class
void JLCVariableCommonChecker::visitTopDef(TopDef *t) {} //abstract class
void JLCVariableCommonChecker::visitArg(Arg *t) {} //abstract class
void JLCVariableCommonChecker::visitBlk(Blk *t) {} //abstract class
void JLCVariableCommonChecker::visitStmt(Stmt *t) {} //abstract class
void JLCVariableCommonChecker::visitItem(Item *t) {} //abstract class
void JLCVariableCommonChecker::visitType(Type *t) {} //abstract class
void JLCVariableCommonChecker::visitExpr(Expr *t) {} //abstract class
void JLCVariableCommonChecker::visitAddOp(AddOp *t) {} //abstract class
void JLCVariableCommonChecker::visitMulOp(MulOp *t) {} //abstract class
void JLCVariableCommonChecker::visitRelOp(RelOp *t) {} //abstract class

void JLCVariableCommonChecker::visitProgram(Program *program)
{
  /* Code For Program Goes Here */
  DEBUG_PRINT( "[" + checkerName +"]" + " visiting Program");
  if (program->listtopdef_) program->listtopdef_->accept(this);

}

void JLCVariableCommonChecker::visitFnDef(FnDef *fn_def)
{
  /* Code For FnDef Goes Here */
  
  if (fn_def->type_) fn_def->type_->accept(this);
  visitIdent(fn_def->ident_);

  // update the current frame name, which mean we are in this function
  globalContext.currentFrameName = fn_def->ident_;
  
  if (fn_def->listarg_) fn_def->listarg_->accept(this);
  DEBUG_PRINT( "[" + checkerName +"]" + " visiting function " + fn_def->ident_);
  if (fn_def->blk_) fn_def->blk_->accept(this);
}

void JLCVariableCommonChecker::visitArgument(Argument *argument)
{
  /* Code For Argument Goes Here */
  if (argument->type_) argument->type_->accept(this);
  visitIdent(argument->ident_);
}

void JLCVariableCommonChecker::visitBlock(Block *block)
{
  /* Code For Block Goes Here */
  DEBUG_PRINT( "[" + checkerName +"]" + " visiting Block");
  // create a new block 
  auto & frame = globalContext.currentFrame();
  frame.newBlock();
  if (block->liststmt_) block->liststmt_->accept(this);
  // release the block
  frame.releaseBlock();

}

void JLCVariableCommonChecker::visitEmpty(Empty *empty)
{
  /* Code For Empty Goes Here */


}

void JLCVariableCommonChecker::visitBStmt(BStmt *b_stmt)
{
  /* Code For BStmt Goes Here */

  if (b_stmt->blk_) b_stmt->blk_->accept(this);

}

void JLCVariableCommonChecker::visitDecl(Decl *decl)
{
  /* Code For Decl Goes Here */
  if (decl->type_) decl->type_->accept(this);
  DEBUG_PRINT( "[" + checkerName +"]" + "\tDeclaring variable: type(" 
    + to_string(temp_type) + ")");
  // cannot declare a variable with void type
  if(temp_type == VOID){
    std::cerr << "ERROR: cannot declare a variable with void type\n";
    exit(1);
  }
  auto temp_decl_type = temp_type;
  auto & frame = globalContext.currentFrame();
  for (auto & item : *(decl->listitem_)){
    temp_type = temp_decl_type;
    item->accept(this);
    if(frame.blk->isExistVar(temp_ident)){
      // check if the variable is already declared in this block !notice: not in the whole function
      std::cerr << "ERROR: variable " << temp_ident << " is already declared.\n";
      exit(1);
    }    
    // Add the variable to the current block
    DEBUG_PRINT( "[" + checkerName +"]" + "\tAdding variable " + temp_ident + " to the block");
    frame.addVar(temp_ident, temp_decl_type);
  }


  
  if (decl->listitem_) decl->listitem_->accept(this);
}

void JLCVariableCommonChecker::visitAss(Ass *ass)
{
  /* Code For Ass Goes Here */

  visitIdent(ass->ident_);
  // check if the variable is already declared in this context
  auto &frame = globalContext.currentFrame();
  if (!frame.isExistVar(ass->ident_)) {
    std::cerr << "ERROR: Variable " << ass->ident_ << " is not declared.\n";
    exit(1);
  }

  if (ass->expr_) ass->expr_->accept(this);
  // check if the expr_ type is same as ass left-hand
  if(temp_type != frame.getVarType(ass->ident_)){
    std::cerr << "ERROR: Type mismatch between expression and variable assignment."
    << " left-hand: "<< ass->ident_ << " type:" 
    << to_string(frame.getVarType(ass->ident_))
    << " right-hand: " << std::string(p.print(ass->expr_)) 
    << " type:" << to_string(temp_type) << '\n';
      exit(1);
  }
}

void JLCVariableCommonChecker::visitIncr(Incr *incr)
{
  /* Code For Incr Goes Here */

  visitIdent(incr->ident_);

}

void JLCVariableCommonChecker::visitDecr(Decr *decr)
{
  /* Code For Decr Goes Here */

  visitIdent(decr->ident_);

}

void JLCVariableCommonChecker::visitRet(Ret *ret)
{
  /* Code For Ret Goes Here */

  if (ret->expr_) ret->expr_->accept(this);

}

void JLCVariableCommonChecker::visitVRet(VRet *v_ret)
{
  /* Code For VRet Goes Here */


}

void JLCVariableCommonChecker::visitCond(Cond *cond)
{
  /* Code For Cond Goes Here */

  if (cond->expr_) cond->expr_->accept(this);
  if (cond->stmt_) cond->stmt_->accept(this);

}

void JLCVariableCommonChecker::visitCondElse(CondElse *cond_else)
{
  /* Code For CondElse Goes Here */

  if (cond_else->expr_) cond_else->expr_->accept(this);
  if (cond_else->stmt_1) cond_else->stmt_1->accept(this);
  if (cond_else->stmt_2) cond_else->stmt_2->accept(this);

}

void JLCVariableCommonChecker::visitWhile(While *while_)
{
  /* Code For While Goes Here */

  if (while_->expr_) while_->expr_->accept(this);
  if (while_->stmt_) while_->stmt_->accept(this);

}

void JLCVariableCommonChecker::visitSExp(SExp *s_exp)
{
  /* Code For SExp Goes Here */
  temp_exp_type = "DEFAULT";
  if (s_exp->expr_) s_exp->expr_->accept(this);
  if (temp_exp_type.find("ELit") != std::string::npos){ 
    std::cerr << "ERROR: expression " + std::string(p.print(s_exp->expr_)) + " is invalid\n";
    exit(1);
  }
}

void JLCVariableCommonChecker::visitNoInit(NoInit *no_init)
{
  /* Code For NoInit Goes Here */
  DEBUG_PRINT( "[" + checkerName +"]" + "\tNoInit");
  visitIdent(no_init->ident_);
  temp_ident = no_init->ident_;

}

void JLCVariableCommonChecker::visitInit(Init *init)
{
  /* Code For Init Goes Here */
  DEBUG_PRINT( "[" + checkerName +"]" + "\tInit");
  visitIdent(init->ident_);
  temp_ident = init->ident_;
  auto temp_decl_type = temp_type;
  if (init->expr_) init->expr_->accept(this);
  // check if the init type is same as the variable type
  if (temp_type != temp_decl_type){
    std::cerr << "ERROR: Type mismatch between expression and variable assignment."
    << " left-hand: "<< init->ident_ << " type:" 
    << to_string(temp_decl_type)
    << " right-hand: " << std::string(p.print(init->expr_)) 
    << " type:" << to_string(temp_type) << "\n";
      exit(1);
  }
}

void JLCVariableCommonChecker::visitInt(Int *int_)
{
  /* Code For Int Goes Here */
  temp_type = INT;
}

void JLCVariableCommonChecker::visitDoub(Doub *doub)
{
  /* Code For Doub Goes Here */
  temp_type = DOUB;
}

void JLCVariableCommonChecker::visitBool(Bool *bool_)
{
  /* Code For Bool Goes Here */
  temp_type = BOOL;

}

void JLCVariableCommonChecker::visitVoid(Void *void_)
{
  /* Code For Void Goes Here */
  temp_type = VOID;

}

void JLCVariableCommonChecker::visitFun(Fun *fun)
{
  /* Code For Fun Goes Here */

  if (fun->type_) fun->type_->accept(this);
  if (fun->listtype_) fun->listtype_->accept(this);

}

void JLCVariableCommonChecker::visitEVar(EVar *e_var)
{
  /* Code For EVar Goes Here */
  // check if the variable is declared
  auto & frame = globalContext.currentFrame();
  if(!frame.isExistVar(e_var->ident_)){
    std::cerr << "ERROR: variable " << e_var->ident_ << " is not declared\n";
    exit(1);
  }
  temp_type = frame.getVarType(e_var->ident_);
  visitIdent(e_var->ident_);
}

void JLCVariableCommonChecker::visitELitInt(ELitInt *e_lit_int)
{
  /* Code For ELitInt Goes Here */
  temp_exp_type = "ELitInt";
  visitInteger(e_lit_int->integer_);
  temp_type = INT;

}

void JLCVariableCommonChecker::visitELitDoub(ELitDoub *e_lit_doub)
{
  /* Code For ELitDoub Goes Here */
  temp_exp_type = "ELitDoub";
  visitDouble(e_lit_doub->double_);
  temp_type = DOUB;

}

void JLCVariableCommonChecker::visitELitTrue(ELitTrue *e_lit_true)
{
  /* Code For ELitTrue Goes Here */
  temp_exp_type = "ELitTrue";
  temp_type = BOOL;

}

void JLCVariableCommonChecker::visitELitFalse(ELitFalse *e_lit_false)
{
  /* Code For ELitFalse Goes Here */
  temp_exp_type = "ELitFalse";
  temp_type = BOOL;
}

void JLCVariableCommonChecker::visitEApp(EApp *e_app)
{
  /* Code For EApp Goes Here */
  DEBUG_PRINT( "[" + checkerName +"]" + " \tvisiting function call " + e_app->ident_);
  // check if the function is declared
  if(!globalContext.isExistFunction(e_app->ident_)){
    std::cerr << "ERROR: function " << e_app->ident_ << " is not declared\n";
    exit(1);
  }
  
  auto & frame = globalContext.getFrame(e_app->ident_);
  // check if the number of arguments is correct
  if(frame.args.size() != e_app->listexpr_->size()){
    std::cerr << "ERROR: function " << e_app->ident_ << " has " << frame.args.size() 
    << " arguments, but " << e_app->listexpr_->size() << " arguments are provided\n";
    exit(1);
  }

  // check if the type of arguments is correct
  auto i = e_app->listexpr_->begin();
  for(auto & arg : frame.args){
    (*i)->accept(this);
    if(temp_type != arg.second){
      std::cerr << "ERROR: function " << e_app->ident_ << " has " << arg.first << 
      " argument with type:" << to_string(arg.second) << ", but " << to_string(temp_type) << " argument is provided\n";
      exit(1);
    }
    i++;
  }
  temp_type = frame.returnType;

  // visitIdent(e_app->ident_);
  // if (e_app->listexpr_) e_app->listexpr_->accept(this);
  
  temp_exp_type = "EApp";
}

void JLCVariableCommonChecker::visitEString(EString *e_string)
{
  /* Code For EString Goes Here */
  temp_exp_type = "ELitString";
  temp_type = STRING;
  visitString(e_string->string_);

}

void JLCVariableCommonChecker::visitNeg(Neg *neg)
{
  /* Code For Neg Goes Here */

  if (neg->expr_) neg->expr_->accept(this);
  // type dont' change
  // temp_type = temp_type;
}

void JLCVariableCommonChecker::visitNot(Not *not_)
{
  /* Code For Not Goes Here */

  if (not_->expr_) not_->expr_->accept(this);

}

void JLCVariableCommonChecker::visitEMul(EMul *e_mul)
{
  /* Code For EMul Goes Here */

  if (e_mul->expr_1) e_mul->expr_1->accept(this);
  if (e_mul->mulop_) e_mul->mulop_->accept(this);
  if (e_mul->expr_2) e_mul->expr_2->accept(this);

}

void JLCVariableCommonChecker::visitEAdd(EAdd *e_add)
{
  /* Code For EAdd Goes Here */

  if (e_add->expr_1) e_add->expr_1->accept(this);
  if (e_add->addop_) e_add->addop_->accept(this);
  if (e_add->expr_2) e_add->expr_2->accept(this);

}

void JLCVariableCommonChecker::visitERel(ERel *e_rel)
{
  /* Code For ERel Goes Here */

  if (e_rel->expr_1) e_rel->expr_1->accept(this);
  if (e_rel->relop_) e_rel->relop_->accept(this);
  if (e_rel->expr_2) e_rel->expr_2->accept(this);
  temp_type = BOOL;
}

void JLCVariableCommonChecker::visitEAnd(EAnd *e_and)
{
  /* Code For EAnd Goes Here */

  if (e_and->expr_1) e_and->expr_1->accept(this);
  // check if the type of the first expression is bool
  if(temp_type != BOOL){
    std::cerr << "ERROR: expression " + std::string(p.print(e_and->expr_1)) + " is not bool type\n";
    exit(1);
  }

  if (e_and->expr_2) e_and->expr_2->accept(this);
  // check if the type of the second expression is bool
  if(temp_type != BOOL){
    std::cerr << "ERROR: expression " + std::string(p.print(e_and->expr_2)) + " is not bool type\n";
    exit(1);
  }
  temp_type = BOOL;
}

void JLCVariableCommonChecker::visitEOr(EOr *e_or)
{
  /* Code For EOr Goes Here */

  if (e_or->expr_1) e_or->expr_1->accept(this);
  // check if the type of the first expression is bool
  if(temp_type != BOOL){
    std::cerr << "ERROR: expression " + std::string(p.print(e_or->expr_1)) + " is not bool type\n";
    exit(1);
  }
  if (e_or->expr_2) e_or->expr_2->accept(this);
  // check if the type of the second expression is bool
  if(temp_type != BOOL){
    std::cerr << "ERROR: expression " + std::string(p.print(e_or->expr_2)) + " is not bool type\n";
    exit(1);
  }
  temp_type = BOOL;
}

void JLCVariableCommonChecker::visitPlus(Plus *plus)
{
  /* Code For Plus Goes Here */


}

void JLCVariableCommonChecker::visitMinus(Minus *minus)
{
  /* Code For Minus Goes Here */


}

void JLCVariableCommonChecker::visitTimes(Times *times)
{
  /* Code For Times Goes Here */


}

void JLCVariableCommonChecker::visitDiv(Div *div)
{
  /* Code For Div Goes Here */


}

void JLCVariableCommonChecker::visitMod(Mod *mod)
{
  /* Code For Mod Goes Here */


}

void JLCVariableCommonChecker::visitLTH(LTH *lth)
{
  /* Code For LTH Goes Here */


}

void JLCVariableCommonChecker::visitLE(LE *le)
{
  /* Code For LE Goes Here */


}

void JLCVariableCommonChecker::visitGTH(GTH *gth)
{
  /* Code For GTH Goes Here */


}

void JLCVariableCommonChecker::visitGE(GE *ge)
{
  /* Code For GE Goes Here */


}

void JLCVariableCommonChecker::visitEQU(EQU *equ)
{
  /* Code For EQU Goes Here */


}

void JLCVariableCommonChecker::visitNE(NE *ne)
{
  /* Code For NE Goes Here */


}


void JLCVariableCommonChecker::visitListTopDef(ListTopDef *list_top_def)
{
  for (ListTopDef::iterator i = list_top_def->begin() ; i != list_top_def->end() ; ++i)
  {
    (*i)->accept(this);
  }
}

void JLCVariableCommonChecker::visitListArg(ListArg *list_arg)
{
  for (ListArg::iterator i = list_arg->begin() ; i != list_arg->end() ; ++i)
  {
    (*i)->accept(this);
  }
}

void JLCVariableCommonChecker::visitListStmt(ListStmt *list_stmt)
{
  for (ListStmt::iterator i = list_stmt->begin() ; i != list_stmt->end() ; ++i)
  {
    DEBUG_PRINT( "[" + checkerName +"]" + " \tvisiting statement");
    (*i)->accept(this);
  }
}

void JLCVariableCommonChecker::visitListItem(ListItem *list_item)
{
  for (ListItem::iterator i = list_item->begin() ; i != list_item->end() ; ++i)
  {
    DEBUG_PRINT( "[" + checkerName +"]" + "\t\tvisiting list item");
    (*i)->accept(this);
  }
}

void JLCVariableCommonChecker::visitListType(ListType *list_type)
{
  for (ListType::iterator i = list_type->begin() ; i != list_type->end() ; ++i)
  {
    (*i)->accept(this);
  }
}

void JLCVariableCommonChecker::visitListExpr(ListExpr *list_expr)
{
  for (ListExpr::iterator i = list_expr->begin() ; i != list_expr->end() ; ++i)
  {
    DEBUG_PRINT( "[" + checkerName +"]" + " \tvisiting expression");
    (*i)->accept(this);
  }
}


void JLCVariableCommonChecker::visitInteger(Integer x)
{
  /* Code for Integer Goes Here */
}

void JLCVariableCommonChecker::visitChar(Char x)
{
  /* Code for Char Goes Here */
}

void JLCVariableCommonChecker::visitDouble(Double x)
{
  /* Code for Double Goes Here */
}

void JLCVariableCommonChecker::visitString(String x)
{
  /* Code for String Goes Here */
}

void JLCVariableCommonChecker::visitIdent(Ident x)
{
  /* Code for Ident Goes Here */
}



