/* File generated by the BNF Converter (bnfc 2.9.4). */

/*** Visitor Design Pattern JLCLLVMGenerator. ***/
/* This implements the common visitor design pattern.
   Note that this method uses Visitor-traversal of lists, so
   List->accept() does NOT traverse the list. This allows different
   algorithms to use context information differently. */

#include "JLCLLVMGenerator.H"
#include "util.h"
#include "Printer.H"

#include <iostream>
#include <string>
#include <sstream>
#include <cstdlib>

#include "llvm/Support/raw_ostream.h"

static PrintAbsyn p = PrintAbsyn();

static const std::string GeneratorName = "JLCLLVMGenerator";

/*
  this function is used to convert the type_enum to string
  @return: llvm::Type*
  @param: type_enum t
*/
llvm::Type* JLCLLVMGenerator::convertType(type_enum t){
  switch (t)
  {
  case INT:
    return llvm::Type::getInt32Ty(*LLVM_Context_);
  case DOUB:
    return llvm::Type::getDoubleTy(*LLVM_Context_);
  case BOOL:
    return llvm::Type::getInt1Ty(*LLVM_Context_);
  case VOID:
    return llvm::Type::getVoidTy(*LLVM_Context_);
  case CHAR:
    return llvm::Type::getInt8Ty(*LLVM_Context_);
  case STRING: // the atcually out is ptr not i8*, is it ok? @todo
    return llvm::Type::getInt8PtrTy(*LLVM_Context_);
  default:
    std::cerr << "Error, Unknown type:" << to_string(t) << std::endl;
    exit(1);
  }
}

void JLCLLVMGenerator::addExternalFunc(){
  for (auto & func : globalContext.funcs)
  {
    addFuncDeclearation(func.second);
  }  
}

void JLCLLVMGenerator::addFuncDeclearation(Frame &frame){
  // see the tutorial about llvm: 
  std::string func_name = frame.name;
  auto llvm_return_type = convertType(frame.returnType);
  std::vector<llvm::Type*> llvm_args;
  for (auto & arg : frame.args)
  {
    llvm_args.push_back(convertType(arg.second));
  }
  llvm::FunctionType* func_type = 
    llvm::FunctionType::get(llvm_return_type, llvm_args, false);
  auto func_dec = llvm::Function::Create(
      func_type, 
      llvm::Function::ExternalLinkage, 
      func_name, 
      LLVM_module_.get());
  
  std::string ss;
  llvm::raw_string_ostream ss2(ss);
  func_dec->print(ss2);
  DEBUG_PRINT("Add function declearation: " + ss);
}


void JLCLLVMGenerator::visitProgram(Program *program)
{
  /* Code For Program Goes Here */
  /* iterate through the top definitions */
  // this part is same as the type checker, will add all the functions to the context
  for (ListTopDef::iterator top_def = program->listtopdef_->begin() ; top_def != program->listtopdef_->end() ; ++top_def)
  {
    FnDef* fn_def = reinterpret_cast<FnDef*>(*top_def);
    visitIdent(fn_def->ident_);
    // add the function to the global context
    globalContext.addFrame(fn_def->ident_);
    globalContext.currentFrameName = fn_def->ident_;

    // update the function return type
    Frame& func = globalContext.getFrame(fn_def->ident_);
    fn_def->type_->accept(this);
    func.returnType = temp_type;

    // check function arguments
    if (fn_def->listarg_) fn_def->listarg_->accept(this);

    // add to llvm module - start
    // @todo maybe we can drop the self-defined CONTEXT, 
    // and use the llvm::Module directly

    auto llvm_return_type = convertType(func.returnType);
    std::vector<llvm::Type*> llvm_args;
    for (auto & arg : func.args)
    {
      llvm_args.push_back(convertType(arg.second));
    }
    llvm::FunctionType* func_type = 
      llvm::FunctionType::get(llvm_return_type, llvm_args, false);
    auto local_llvm_func = llvm::Function::Create(
        func_type, 
        llvm::Function::ExternalLinkage, 
        func.name, 
        LLVM_module_.get());
    
    // set arguments name
    auto arg_iter = local_llvm_func->arg_begin();
    for (size_t i = 0; i < func.args.size(); i++)
    {
      arg_iter->setName(func.args[i].first);
      arg_iter++;
    }
    // add to llvm module - end 
    // debug print
    std::string ss;
    llvm::raw_string_ostream ss2(ss);
    local_llvm_func->print(ss2);
    DEBUG_PRINT("Add function define: " + ss);
  }
  
  if (program->listtopdef_) program->listtopdef_->accept(this);

}

void JLCLLVMGenerator::visitFnDef(FnDef *fn_def)
{
  /* Code For FnDef Goes Here */
  globalContext.currentFrameName = fn_def->ident_; // set context to the current function

  // reset inner variables before visiting the function body
  block_id = 0;
  block_var_map_list.clear();

  // cotinue to iterate the function body
  if (fn_def->blk_) fn_def->blk_->accept(this);
}

void JLCLLVMGenerator::visitArgument(Argument *argument)
{
  /* Code For Argument Goes Here */
  // this part is same as the type checker,
  // will add all the arguments to the function
  // but does not check the types of the arguments in generator
    if (argument->type_) argument->type_->accept(this);
    DEBUG_PRINT("\tArgument name: " + argument->ident_ + 
      "\tArgument type: " + to_string(temp_type));
    Frame& func = globalContext.getFrame(globalContext.currentFrameName);
    // add the argument to the function
    func.addArg(argument->ident_, temp_type);
}

void JLCLLVMGenerator::visitBlock(Block *block)
{
  /* Code For Block Goes Here */
  DEBUG_PRINT( "[" + GeneratorName  +"]" + " visiting Block");
  // create a new block 
  auto & func = globalContext.currentFrame();
  func.newBlock();
  addBlockVarMap();
  // add a new block to the function
  auto llvm_func = LLVM_module_->getFunction(func.name);
  llvm::BasicBlock* entry = 
    llvm::BasicBlock::Create(*LLVM_Context_, getBlockName(), llvm_func);
  LLVM_builder_->SetInsertPoint(entry);
  block_id++;

  DEBUG_PRINT("init args");
  // if the block is the function body, we need to add the arguments to the block
  if (func.blk->parent == nullptr)
  {
    for (auto & arg : func.args)
    {
      auto arg_iter = llvm_func->arg_begin();
      for (size_t i = 0; i < func.args.size(); i++)
      {
        if (arg.first == std::string(arg_iter->getName()))
        {   
          auto alloca = LLVM_builder_->CreateAlloca(convertType(arg.second), nullptr, arg.first);
          LLVM_builder_->CreateStore(arg_iter, alloca);
          addVarToBlockMap(arg.first, alloca);
          break;
        }
        arg_iter++;
      }
    }
  }
  DEBUG_PRINT("go through the block")
  if (block->liststmt_) block->liststmt_->accept(this);
  // check if the predecessor block is terminated
  if (LLVM_builder_->GetInsertBlock()->getTerminator() == nullptr)
  {
    // if the block is not terminated, we need to add a return statement
    if (func.returnType == VOID)
    {
      LLVM_builder_->CreateRetVoid();
    }
    else
    {
     std::cerr << "Error: function block does not have a return statement" << std::endl;
     exit(1);
    }
  }

  // release the block
  DEBUG_PRINT("release block");
  func.releaseBlock();
  removeBlockVarMap();
}

void JLCLLVMGenerator::visitEmpty(Empty *empty)
{
  /* Code For Empty Goes Here */


}

void JLCLLVMGenerator::visitBStmt(BStmt *b_stmt)
{
  /* Code For BStmt Goes Here */

  if (b_stmt->blk_) b_stmt->blk_->accept(this);

}

void JLCLLVMGenerator::visitDecl(Decl *decl)
{
  /* Code For Decl Goes Here */
  if (decl->type_) decl->type_->accept(this);
  auto temp_decl_type = temp_type;
  for (auto & item : *(decl->listitem_)){
    temp_type = temp_decl_type; // !! this is important, as the type will pase to the next level
    item->accept(this);
  }
}

void JLCLLVMGenerator::visitAss(Ass *ass)
{
  /* Code For Ass Goes Here */

  visitIdent(ass->ident_);
  if (ass->expr_) ass->expr_->accept(this);
  // llvm_temp_value_ is set by next level (accept)
  auto var = getVarFromBlockMap(ass->ident_);
  LLVM_builder_->CreateStore(llvm_temp_value_, var);
}

void JLCLLVMGenerator::visitIncr(Incr *incr)
{
  /* Code For Incr Goes Here */

  // visitIdent(incr->ident_);
  // x++ -> x=x+1
  auto var = getVarFromBlockMap(incr->ident_);
  // load x must but int type, it will be check by the typer checker
  auto load = LLVM_builder_->CreateLoad(
      convertType(INT), var, incr->ident_);
  // add with 1 
  auto op = LLVM_builder_->CreateAdd(
        load, 
        llvm::ConstantInt::get(*LLVM_Context_, 
            llvm::APInt(32, 1)),
        "add");
  // store
  LLVM_builder_->CreateStore(op, var);
}

void JLCLLVMGenerator::visitDecr(Decr *decr)
{
  /* Code For Decr Goes Here */

  // visitIdent(decr->ident_);
  // x-- -> x=x-1
  auto var = getVarFromBlockMap(decr->ident_);
  // load x must but int type, it will be check by the typer checker
  auto load = LLVM_builder_->CreateLoad(
      convertType(INT), var, decr->ident_);
  // sub 1 
  auto op = LLVM_builder_->CreateSub(
        load, 
        llvm::ConstantInt::get(*LLVM_Context_, 
            llvm::APInt(32, 1)),
        "sub");
  // store
  LLVM_builder_->CreateStore(op, var);
  // store does not return a value, 
  // so we do not need to set llvm_temp_value_
}

void JLCLLVMGenerator::visitRet(Ret *ret)
{
  /* Code For Ret Goes Here */

  if (ret->expr_) ret->expr_->accept(this);
  // add llvm return 
  LLVM_builder_->CreateRet(llvm_temp_value_);
}

void JLCLLVMGenerator::visitVRet(VRet *v_ret)
{
  /* Code For VRet Goes Here */
  LLVM_builder_->CreateRetVoid();
  DEBUG_PRINT("visitVRet");
}

void JLCLLVMGenerator::visitCond(Cond *cond)
{
  /* Code For Cond Goes Here */

  if (cond->expr_) cond->expr_->accept(this);
  if (cond->stmt_) cond->stmt_->accept(this);

}

void JLCLLVMGenerator::visitCondElse(CondElse *cond_else)
{
  /* Code For CondElse Goes Here */

  if (cond_else->expr_) cond_else->expr_->accept(this);
  if (cond_else->stmt_1) cond_else->stmt_1->accept(this);
  if (cond_else->stmt_2) cond_else->stmt_2->accept(this);

}

void JLCLLVMGenerator::visitWhile(While *while_)
{
  /* Code For While Goes Here */

  if (while_->expr_) while_->expr_->accept(this);
  if (while_->stmt_) while_->stmt_->accept(this);

}

void JLCLLVMGenerator::visitSExp(SExp *s_exp)
{
  /* Code For SExp Goes Here */

  if (s_exp->expr_) s_exp->expr_->accept(this);

}

void JLCLLVMGenerator::visitNoInit(NoInit *no_init)
{
  /* Code For NoInit Goes Here */
  visitIdent(no_init->ident_);
  auto temp_decl_type = temp_type; // !this type is passed from top level
  auto & frame = globalContext.currentFrame();
  frame.addVar(no_init->ident_, temp_decl_type);

  
  llvm::Constant* init_val = nullptr;
  switch (temp_decl_type)
  {
  case INT:
    init_val = llvm::ConstantInt::get(*LLVM_Context_, llvm::APInt(32, 0));
    break;
  case DOUB:
    init_val = llvm::ConstantFP::get(*LLVM_Context_, llvm::APFloat(0.0));
    break;
  default:
    break;
  }
  /*todo: this should be an optional part, 
    which initialize the variable when allocates the memory
    now we just first allocate the memory, and then use sort to initialize the memory
  */ 
  // auto alloca = LLVM_builder_->CreateAlloca(convertType(temp_type), init_val, no_init->ident_);
  auto alloca = LLVM_builder_->CreateAlloca(convertType(temp_type), nullptr, no_init->ident_);
  addVarToBlockMap(no_init->ident_, alloca);
  if (init_val != nullptr)
  {
    LLVM_builder_->CreateStore(init_val, alloca);
    //@TODO: a better way to add comments
    llvm::MDNode* N = llvm::MDNode::get(*LLVM_Context_, 
      llvm::MDString::get(*LLVM_Context_, "Default value: 0"));
    alloca->setMetadata("comment", N);
  }
}

void JLCLLVMGenerator::visitInit(Init *init)
{
  /* Code For Init Goes Here */
  visitIdent(init->ident_);
  auto temp_decl_type = temp_type; // !this type is passed from top level
  auto & frame = globalContext.currentFrame();
  frame.addVar(init->ident_, temp_decl_type);
  
  auto alloca = LLVM_builder_->CreateAlloca(convertType(temp_decl_type), nullptr, init->ident_);
  // add the variable to the block map
  addVarToBlockMap(init->ident_, alloca);

  if (init->expr_) init->expr_->accept(this);
  // store a constant value to the memory
  LLVM_builder_->CreateStore(llvm_temp_value_, alloca);
}

void JLCLLVMGenerator::visitInt(Int *int_)
{
  /* Code For Int Goes Here */
  temp_type = INT;

}

void JLCLLVMGenerator::visitDoub(Doub *doub)
{
  /* Code For Doub Goes Here */
  temp_type = DOUB;
}

void JLCLLVMGenerator::visitBool(Bool *bool_)
{
  /* Code For Bool Goes Here */
  temp_type = BOOL;
}

void JLCLLVMGenerator::visitVoid(Void *void_)
{
  /* Code For Void Goes Here */
  temp_type = VOID;
}

void JLCLLVMGenerator::visitFun(Fun *fun)
{
  /* Code For Fun Goes Here */

  if (fun->type_) fun->type_->accept(this);
  if (fun->listtype_) fun->listtype_->accept(this);

}

void JLCLLVMGenerator::visitEVar(EVar *e_var)
{
  /* Code For EVar Goes Here */
  auto & frame = globalContext.currentFrame();
  temp_type = frame.getVarType(e_var->ident_);
  // visitIdent(e_var->ident_);
  
  // when we access a variable, we need to load the value from the memory
  // llvm load 
  llvm::Value* var = getVarFromBlockMap(e_var->ident_);
  llvm_temp_value_ = LLVM_builder_->CreateLoad(convertType(temp_type), var, e_var->ident_);
}

void JLCLLVMGenerator::visitELitInt(ELitInt *e_lit_int)
{
  /* Code For ELitInt Goes Here */

  visitInteger(e_lit_int->integer_);
  temp_type = INT;
  
  // llvm constant
  llvm_temp_value_ = llvm::ConstantInt::get(*LLVM_Context_, llvm::APInt(32, e_lit_int->integer_));

}

void JLCLLVMGenerator::visitELitDoub(ELitDoub *e_lit_doub)
{
  /* Code For ELitDoub Goes Here */

  visitDouble(e_lit_doub->double_);
  temp_type = DOUB;
  // llvm constant
  llvm_temp_value_ = llvm::ConstantFP::get(*LLVM_Context_, llvm::APFloat(e_lit_doub->double_));
}

void JLCLLVMGenerator::visitELitTrue(ELitTrue *e_lit_true)
{
  /* Code For ELitTrue Goes Here */

  temp_type = BOOL;
  // llvm constant 
  llvm_temp_value_ = llvm::ConstantInt::get(*LLVM_Context_, llvm::APInt(1, 1));

}

void JLCLLVMGenerator::visitELitFalse(ELitFalse *e_lit_false)
{
  /* Code For ELitFalse Goes Here */
  temp_type = BOOL;
  // llvm constant
  llvm_temp_value_ = llvm::ConstantInt::get(*LLVM_Context_, llvm::APInt(1, 0));
}

void JLCLLVMGenerator::visitEApp(EApp *e_app)
{
  DEBUG_PRINT("Visit EApp: " + e_app->ident_);
  /* Code For EApp Goes Here */
  std::vector<llvm::Value*> args;
  // iterate through the arguments, and collect the llvm values
  for (auto & expr : *(e_app->listexpr_))
  {
    expr->accept(this);
    args.push_back(llvm_temp_value_);
  }
  // add llvm function call
  auto llvm_func = LLVM_module_->getFunction(e_app->ident_);
  // check if the return type is void
  std::string tag = "";
  DEBUG_PRINT("EApp check return type")
  if (!llvm_func->getReturnType()->isVoidTy())
  {
    DEBUG_PRINT("EApp return type is not void")
    // if return type is void, then we have to pass empty string as tag
    tag = e_app->ident_;
  }
  DEBUG_PRINT("EApp create call")
  llvm_temp_value_ = LLVM_builder_->CreateCall(llvm_func, args, tag);
  DEBUG_PRINT("Call function: " + e_app->ident_);
}

void JLCLLVMGenerator::visitEString(EString *e_string)
{
  /* Code For EString Goes Here */
  temp_type = STRING;
  
  // check if the string is already in the global context
  // @TODO: this is not a good way to store the string, 
  //        using llvm api to check if a string is already in the global context
  // why we convert string to id? Considering the case a very long string.
  static int global_string_id = 0;
  static std::map<std::string, int> string_id_map;
  static std::map<int, llvm::GlobalVariable*> global_sid_var_map;
  
  int id = -1;
  if (string_id_map.find(e_string->string_) == string_id_map.end())
  {
    string_id_map[e_string->string_] = global_string_id;
    global_string_id++;
  }
  id = string_id_map[e_string->string_];
  if (global_sid_var_map.find(id) == global_sid_var_map.end())
  {
    DEBUG_PRINT("Add string to global context: " 
      + e_string->string_ + " id: " + std::to_string(id));

    auto global_var = new llvm::GlobalVariable(
      *LLVM_module_, 
      llvm::ArrayType::get(llvm::Type::getInt8Ty(*LLVM_Context_), e_string->string_.size() + 1),
      true,
      llvm::GlobalValue::PrivateLinkage,
      llvm::ConstantDataArray::getString(*LLVM_Context_, e_string->string_),
      "str" + std::to_string(id)
    );
    global_sid_var_map[id] = global_var;
  }

  llvm_temp_value_ = global_sid_var_map[id];
}

void JLCLLVMGenerator::visitNeg(Neg *neg)
{
  /* Code For Neg Goes Here */

  if (neg->expr_) neg->expr_->accept(this);
  // llvm neg
  llvm_temp_value_ = LLVM_builder_->CreateNeg(llvm_temp_value_);
}

void JLCLLVMGenerator::visitNot(Not *not_)
{
  /* Code For Not Goes Here */

  if (not_->expr_) not_->expr_->accept(this);
  // llvm not
  llvm_temp_value_ = LLVM_builder_->CreateNot(llvm_temp_value_);

}

void JLCLLVMGenerator::visitEMul(EMul *e_mul)
{
  /* Code For EMul Goes Here */

  if (e_mul->expr_1) e_mul->expr_1->accept(this);
  auto expr_1_llvm_value = llvm_temp_value_;
  if (e_mul->mulop_) e_mul->mulop_->accept(this);
  auto local_op = temp_op;
  if (e_mul->expr_2) e_mul->expr_2->accept(this);
  auto expr_2_llvm_value = llvm_temp_value_;

  switch (local_op)
  {
  case eMUL:
    llvm_temp_value_ = LLVM_builder_->CreateMul(
        expr_1_llvm_value, expr_2_llvm_value, "mul");
    break;
  case eDIV:
    llvm_temp_value_ = LLVM_builder_->CreateSDiv(
        expr_1_llvm_value, expr_2_llvm_value, "div");
    break;
  case eMOD:
    llvm_temp_value_ = LLVM_builder_->CreateSRem(
        expr_1_llvm_value, expr_2_llvm_value, "mod");
    break;
  default:
    std::cerr << "Error: unknown EMUL operation."<< std::endl;
    exit(1);
    break;
  }
}

void JLCLLVMGenerator::visitEAdd(EAdd *e_add)
{
  /* Code For EAdd Goes Here */

  if (e_add->expr_1) e_add->expr_1->accept(this);
  auto expr_1_llvm_value = llvm_temp_value_;
  if (e_add->addop_) e_add->addop_->accept(this);
  auto local_op = temp_op;
  if (e_add->expr_2) e_add->expr_2->accept(this);
  auto expr_2_llvm_value = llvm_temp_value_;

  switch (local_op)
  {
  case eADD:
    llvm_temp_value_ = LLVM_builder_->CreateAdd(
        expr_1_llvm_value, expr_2_llvm_value, "add");
    break;
  case eSUB:
    llvm_temp_value_ = LLVM_builder_->CreateSub(
        expr_1_llvm_value, expr_2_llvm_value, "sub");
    break;
  default:
    std::cerr << "Error: unknown EADD operation."<< std::endl;
    exit(1);
    break;
  }

}

void JLCLLVMGenerator::visitERel(ERel *e_rel)
{
  /* Code For ERel Goes Here */
  if (e_rel->expr_1) e_rel->expr_1->accept(this);
  auto expr_1_llvm_value = llvm_temp_value_;
  if (e_rel->relop_) e_rel->relop_->accept(this);
  auto local_op = temp_op;
  if (e_rel->expr_2) e_rel->expr_2->accept(this);
  auto expr_2_llvm_value = llvm_temp_value_;

  switch (local_op)
  {
  case eLT:
    llvm_temp_value_ = LLVM_builder_->CreateICmpSLT(
        expr_1_llvm_value, expr_2_llvm_value, "lt");
    break;
  case eLE:
    llvm_temp_value_ = LLVM_builder_->CreateICmpSLE(
        expr_1_llvm_value, expr_2_llvm_value, "le");
    break;
  case eGT:
    llvm_temp_value_ = LLVM_builder_->CreateICmpSGT(
        expr_1_llvm_value, expr_2_llvm_value, "gt");
    break;
  case eGE:
    llvm_temp_value_ = LLVM_builder_->CreateICmpSGE(
        expr_1_llvm_value, expr_2_llvm_value, "ge");
    break;
  case eEQ:
    llvm_temp_value_ = LLVM_builder_->CreateICmpEQ(
        expr_1_llvm_value, expr_2_llvm_value, "eq");
    break;
  case eNE:
    llvm_temp_value_ = LLVM_builder_->CreateICmpNE(
        expr_1_llvm_value, expr_2_llvm_value, "ne");
    break;
  default:
    std::cerr << "Error: unknown EREL operation."<< std::endl;
    exit(1);
    break;
  }
}

void JLCLLVMGenerator::visitEAnd(EAnd *e_and)
{
  /* Code For EAnd Goes Here */
  auto current_block = LLVM_builder_->GetInsertBlock();
  auto parent = current_block->getParent();
  auto and_true_block = llvm::BasicBlock::Create(*LLVM_Context_, "and.true", parent);
  auto and_end_block = llvm::BasicBlock::Create(*LLVM_Context_, "and.end", parent);

  if (e_and->expr_1) e_and->expr_1->accept(this);
  auto expr_1_llvm_value = llvm_temp_value_;
  // short-circui evaluation
  // if the first expression is false, 
  // then we do not need to evaluate the second expression
  // @todo: how to do this in llvm ?

  LLVM_builder_->CreateCondBr(expr_1_llvm_value, and_true_block, and_end_block);
  LLVM_builder_->SetInsertPoint(and_true_block);
  if (e_and->expr_2) e_and->expr_2->accept(this);
  auto expr_2_llvm_value = llvm_temp_value_;

  LLVM_builder_->CreateBr(and_end_block);
  LLVM_builder_->SetInsertPoint(and_end_block);
  llvm::PHINode* phi = LLVM_builder_->CreatePHI(
      llvm::Type::getInt1Ty(*LLVM_Context_), 2, "and");
  phi->addIncoming(expr_1_llvm_value, current_block);
  phi->addIncoming(expr_2_llvm_value, and_true_block);
  llvm_temp_value_ = phi;

  // reset the block
  // LLVM_builder_->SetInsertPoint(current_block);  @todo: do we really need this?
}

void JLCLLVMGenerator::visitEOr(EOr *e_or)
{
  /* Code For EOr Goes Here */
  auto current_block = LLVM_builder_->GetInsertBlock();
  auto parent = current_block->getParent();
  auto or_false_block = llvm::BasicBlock::Create(*LLVM_Context_, "or.false", parent);
  auto or_end_block = llvm::BasicBlock::Create(*LLVM_Context_, "or.end", parent);

  if (e_or->expr_1) e_or->expr_1->accept(this);
  auto expr_1_llvm_value = llvm_temp_value_;
  // if the first expression is true, then we do not need to evaluate the second expression

  LLVM_builder_->CreateCondBr(expr_1_llvm_value, or_end_block, or_false_block);
  LLVM_builder_->SetInsertPoint(or_false_block);

  if (e_or->expr_2) e_or->expr_2->accept(this);
  auto expr_2_llvm_value = llvm_temp_value_;

  LLVM_builder_->CreateBr(or_end_block);
  LLVM_builder_->SetInsertPoint(or_end_block);
  llvm::PHINode* phi = LLVM_builder_->CreatePHI(
      llvm::Type::getInt1Ty(*LLVM_Context_), 2, "or");
  
  phi->addIncoming(expr_1_llvm_value, current_block);
  phi->addIncoming(expr_2_llvm_value, or_false_block);
  llvm_temp_value_ = phi;

  // reset the block
  // LLVM_builder_->SetInsertPoint(current_block);  @todo: do we really need this?
}

void JLCLLVMGenerator::visitPlus(Plus *plus)
{
  /* Code For Plus Goes Here */
  temp_op = eADD;
}

void JLCLLVMGenerator::visitMinus(Minus *minus)
{
  /* Code For Minus Goes Here */
  temp_op = eSUB;
}

void JLCLLVMGenerator::visitTimes(Times *times)
{
  /* Code For Times Goes Here */
  temp_op = eMUL;
}

void JLCLLVMGenerator::visitDiv(Div *div)
{
  /* Code For Div Goes Here */
  temp_op = eDIV;
}

void JLCLLVMGenerator::visitMod(Mod *mod)
{
  /* Code For Mod Goes Here */
  temp_op = eMOD;
}

void JLCLLVMGenerator::visitLTH(LTH *lth)
{
  /* Code For LTH Goes Here */
  temp_op = eLT;
}

void JLCLLVMGenerator::visitLE(LE *le)
{
  /* Code For LE Goes Here */
  temp_op = eLE;
}

void JLCLLVMGenerator::visitGTH(GTH *gth)
{
  /* Code For GTH Goes Here */
  temp_op = eGT;
}

void JLCLLVMGenerator::visitGE(GE *ge)
{
  /* Code For GE Goes Here */
  temp_op = eGE;
}

void JLCLLVMGenerator::visitEQU(EQU *equ)
{
  /* Code For EQU Goes Here */
  temp_op = eEQ;
}

void JLCLLVMGenerator::visitNE(NE *ne)
{
  /* Code For NE Goes Here */
  temp_op = eNE;
}


void JLCLLVMGenerator::visitListTopDef(ListTopDef *list_top_def)
{
  for (ListTopDef::iterator i = list_top_def->begin() ; i != list_top_def->end() ; ++i)
  {
    (*i)->accept(this);
  }
}

void JLCLLVMGenerator::visitListArg(ListArg *list_arg)
{
  for (ListArg::iterator i = list_arg->begin() ; i != list_arg->end() ; ++i)
  {
    (*i)->accept(this);
  }
}

void JLCLLVMGenerator::visitListStmt(ListStmt *list_stmt)
{
  for (ListStmt::iterator i = list_stmt->begin() ; i != list_stmt->end() ; ++i)
  {
    (*i)->accept(this);
  }
}

void JLCLLVMGenerator::visitListItem(ListItem *list_item)
{
  for (ListItem::iterator i = list_item->begin() ; i != list_item->end() ; ++i)
  {
    (*i)->accept(this);
  }
}

void JLCLLVMGenerator::visitListType(ListType *list_type)
{
  for (ListType::iterator i = list_type->begin() ; i != list_type->end() ; ++i)
  {
    (*i)->accept(this);
  }
}

void JLCLLVMGenerator::visitListExpr(ListExpr *list_expr)
{
  for (ListExpr::iterator i = list_expr->begin() ; i != list_expr->end() ; ++i)
  {
    (*i)->accept(this);
  }
}
