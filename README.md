# Javalette Compiler

# Degisn 
![img](./doc/type_checker.png)

# how to update submodule
```
git submodule update --init
```

# For test
we don't use git submodule here, just clone: https://github.com/TDA283-compiler-construction/project.git

```
# for just parsing and type checking.
python3 testing.py path/to/submission 
```


# FRONT END
+ If you considering running BNFC to regenerate the parser, take a moment to consider: do you really need to do so, and why?

+ For further details on the front-end basic code generated by BNFC: https://bnfc.digitalgrammars.com/


+ why do we seperate the checker into N checkers: for example, case good/core002.jl, all called functions in main function are defined after the main, then in the tree, those nodes will be visted only after the main node is visted. (making things complex if we check everything using a single vistor (checker), even if we save the context.)

## undefined operation: 
- [ ] printInt(x++);
- [x] what about variable name is same as a function name -> see core020.jl

- [x] Short-circui evaluation:
```c
int main () {
  int a =1,b =2;
  if(a<0 && b>0){
    a = 1;
  }
}
```

# extension 

+ priority of array operation 
``` c 
//
printInt(arr.length);

//
while (j<a.length) 

// 
int [] res = new int [a . length];

//
a [i] = a [i + 1];

// 
a[a.length - 1]= x ;

//
res = res + a[i] * b[i];

//
printInt(new int[foo(7)].length);

//
array(3)[2] = 1;
printInt(array(3)[0]);

//
printInt((new int[3])[2]);
```

# priority of C (partial) 

1: () [] . ->

2: "+" "-" "++" "--" "!" "*" "&" "sizeof" "(type)"

3: "*" "/" "%", multiplication operation

4: + - 

5: << >>

6: <<= =>>

7: == !=

11: &&

12: ||

14: = 

15: ,


# JLC original

6: Elit  interger, double, true, false
6: EVar ()
6: EApp (function call) Ident "(" ")"

5: Neg(-), Not(!)

4: Emul 

3: Add

2: Rel < > != ==

1: Eand

0: Eor

# JLC with array
7: [], ELitx, Evar, EApp
6: new, EDOT, 
5: **same as above**

# JLC with struct 
+ typedef 
+ struct
+ -> op, new, ()

7: [], ->
6: new
