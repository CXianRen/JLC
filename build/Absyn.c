/* File generated by the BNF Converter (bnfc 2.9.4). */

/* C Abstract Syntax Implementation. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"

/********************   Program    ********************/

Prog make_Program(ListTopDef p1)
{
    Prog tmp = (Prog) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Program!\n");
        exit(1);
    }
    tmp->kind = is_Program;
    tmp->u.program_.listtopdef_ = p1;
    return tmp;
}

/********************   FnDef    ********************/

TopDef make_FnDef(Type p1, Ident p2, ListArg p3, Blk p4)
{
    TopDef tmp = (TopDef) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FnDef!\n");
        exit(1);
    }
    tmp->kind = is_FnDef;
    tmp->u.fndef_.type_ = p1;
    tmp->u.fndef_.ident_ = p2;
    tmp->u.fndef_.listarg_ = p3;
    tmp->u.fndef_.blk_ = p4;
    return tmp;
}

/********************   ListTopDef    ********************/

ListTopDef make_ListTopDef(TopDef p1, ListTopDef p2)
{
    ListTopDef tmp = (ListTopDef) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListTopDef!\n");
        exit(1);
    }
    tmp->topdef_ = p1;
    tmp->listtopdef_ = p2;
    return tmp;
}

/********************   Argument    ********************/

Arg make_Argument(Type p1, Ident p2)
{
    Arg tmp = (Arg) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Argument!\n");
        exit(1);
    }
    tmp->kind = is_Argument;
    tmp->u.argument_.type_ = p1;
    tmp->u.argument_.ident_ = p2;
    return tmp;
}

/********************   ListArg    ********************/

ListArg make_ListArg(Arg p1, ListArg p2)
{
    ListArg tmp = (ListArg) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListArg!\n");
        exit(1);
    }
    tmp->arg_ = p1;
    tmp->listarg_ = p2;
    return tmp;
}

/********************   Block    ********************/

Blk make_Block(ListStmt p1)
{
    Blk tmp = (Blk) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Block!\n");
        exit(1);
    }
    tmp->kind = is_Block;
    tmp->u.block_.liststmt_ = p1;
    return tmp;
}

/********************   ListStmt    ********************/

ListStmt make_ListStmt(Stmt p1, ListStmt p2)
{
    ListStmt tmp = (ListStmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListStmt!\n");
        exit(1);
    }
    tmp->stmt_ = p1;
    tmp->liststmt_ = p2;
    return tmp;
}

/********************   Empty    ********************/

Stmt make_Empty()
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Empty!\n");
        exit(1);
    }
    tmp->kind = is_Empty;
    return tmp;
}

/********************   BStmt    ********************/

Stmt make_BStmt(Blk p1)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BStmt!\n");
        exit(1);
    }
    tmp->kind = is_BStmt;
    tmp->u.bstmt_.blk_ = p1;
    return tmp;
}

/********************   Decl    ********************/

Stmt make_Decl(Type p1, ListItem p2)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Decl!\n");
        exit(1);
    }
    tmp->kind = is_Decl;
    tmp->u.decl_.type_ = p1;
    tmp->u.decl_.listitem_ = p2;
    return tmp;
}

/********************   Ass    ********************/

Stmt make_Ass(Ident p1, Expr p2)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Ass!\n");
        exit(1);
    }
    tmp->kind = is_Ass;
    tmp->u.ass_.ident_ = p1;
    tmp->u.ass_.expr_ = p2;
    return tmp;
}

/********************   Incr    ********************/

Stmt make_Incr(Ident p1)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Incr!\n");
        exit(1);
    }
    tmp->kind = is_Incr;
    tmp->u.incr_.ident_ = p1;
    return tmp;
}

/********************   Decr    ********************/

Stmt make_Decr(Ident p1)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Decr!\n");
        exit(1);
    }
    tmp->kind = is_Decr;
    tmp->u.decr_.ident_ = p1;
    return tmp;
}

/********************   Ret    ********************/

Stmt make_Ret(Expr p1)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Ret!\n");
        exit(1);
    }
    tmp->kind = is_Ret;
    tmp->u.ret_.expr_ = p1;
    return tmp;
}

/********************   VRet    ********************/

Stmt make_VRet()
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VRet!\n");
        exit(1);
    }
    tmp->kind = is_VRet;
    return tmp;
}

/********************   Cond    ********************/

Stmt make_Cond(Expr p1, Stmt p2)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Cond!\n");
        exit(1);
    }
    tmp->kind = is_Cond;
    tmp->u.cond_.expr_ = p1;
    tmp->u.cond_.stmt_ = p2;
    return tmp;
}

/********************   CondElse    ********************/

Stmt make_CondElse(Expr p1, Stmt p2, Stmt p3)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CondElse!\n");
        exit(1);
    }
    tmp->kind = is_CondElse;
    tmp->u.condelse_.expr_ = p1;
    tmp->u.condelse_.stmt_1 = p2;
    tmp->u.condelse_.stmt_2 = p3;
    return tmp;
}

/********************   While    ********************/

Stmt make_While(Expr p1, Stmt p2)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating While!\n");
        exit(1);
    }
    tmp->kind = is_While;
    tmp->u.while_.expr_ = p1;
    tmp->u.while_.stmt_ = p2;
    return tmp;
}

/********************   SExp    ********************/

Stmt make_SExp(Expr p1)
{
    Stmt tmp = (Stmt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SExp!\n");
        exit(1);
    }
    tmp->kind = is_SExp;
    tmp->u.sexp_.expr_ = p1;
    return tmp;
}

/********************   NoInit    ********************/

Item make_NoInit(Ident p1)
{
    Item tmp = (Item) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating NoInit!\n");
        exit(1);
    }
    tmp->kind = is_NoInit;
    tmp->u.noinit_.ident_ = p1;
    return tmp;
}

/********************   Init    ********************/

Item make_Init(Ident p1, Expr p2)
{
    Item tmp = (Item) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Init!\n");
        exit(1);
    }
    tmp->kind = is_Init;
    tmp->u.init_.ident_ = p1;
    tmp->u.init_.expr_ = p2;
    return tmp;
}

/********************   ListItem    ********************/

ListItem make_ListItem(Item p1, ListItem p2)
{
    ListItem tmp = (ListItem) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListItem!\n");
        exit(1);
    }
    tmp->item_ = p1;
    tmp->listitem_ = p2;
    return tmp;
}

/********************   Int    ********************/

Type make_Int()
{
    Type tmp = (Type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Int!\n");
        exit(1);
    }
    tmp->kind = is_Int;
    return tmp;
}

/********************   Doub    ********************/

Type make_Doub()
{
    Type tmp = (Type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Doub!\n");
        exit(1);
    }
    tmp->kind = is_Doub;
    return tmp;
}

/********************   Bool    ********************/

Type make_Bool()
{
    Type tmp = (Type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Bool!\n");
        exit(1);
    }
    tmp->kind = is_Bool;
    return tmp;
}

/********************   Void    ********************/

Type make_Void()
{
    Type tmp = (Type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Void!\n");
        exit(1);
    }
    tmp->kind = is_Void;
    return tmp;
}

/********************   Fun    ********************/

Type make_Fun(Type p1, ListType p2)
{
    Type tmp = (Type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Fun!\n");
        exit(1);
    }
    tmp->kind = is_Fun;
    tmp->u.fun_.type_ = p1;
    tmp->u.fun_.listtype_ = p2;
    return tmp;
}

/********************   ListType    ********************/

ListType make_ListType(Type p1, ListType p2)
{
    ListType tmp = (ListType) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListType!\n");
        exit(1);
    }
    tmp->type_ = p1;
    tmp->listtype_ = p2;
    return tmp;
}

/********************   EVar    ********************/

Expr make_EVar(Ident p1)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EVar!\n");
        exit(1);
    }
    tmp->kind = is_EVar;
    tmp->u.evar_.ident_ = p1;
    return tmp;
}

/********************   ELitInt    ********************/

Expr make_ELitInt(Integer p1)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ELitInt!\n");
        exit(1);
    }
    tmp->kind = is_ELitInt;
    tmp->u.elitint_.integer_ = p1;
    return tmp;
}

/********************   ELitDoub    ********************/

Expr make_ELitDoub(Double p1)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ELitDoub!\n");
        exit(1);
    }
    tmp->kind = is_ELitDoub;
    tmp->u.elitdoub_.double_ = p1;
    return tmp;
}

/********************   ELitTrue    ********************/

Expr make_ELitTrue()
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ELitTrue!\n");
        exit(1);
    }
    tmp->kind = is_ELitTrue;
    return tmp;
}

/********************   ELitFalse    ********************/

Expr make_ELitFalse()
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ELitFalse!\n");
        exit(1);
    }
    tmp->kind = is_ELitFalse;
    return tmp;
}

/********************   EApp    ********************/

Expr make_EApp(Ident p1, ListExpr p2)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EApp!\n");
        exit(1);
    }
    tmp->kind = is_EApp;
    tmp->u.eapp_.ident_ = p1;
    tmp->u.eapp_.listexpr_ = p2;
    return tmp;
}

/********************   EString    ********************/

Expr make_EString(String p1)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EString!\n");
        exit(1);
    }
    tmp->kind = is_EString;
    tmp->u.estring_.string_ = p1;
    return tmp;
}

/********************   Neg    ********************/

Expr make_Neg(Expr p1)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Neg!\n");
        exit(1);
    }
    tmp->kind = is_Neg;
    tmp->u.neg_.expr_ = p1;
    return tmp;
}

/********************   Not    ********************/

Expr make_Not(Expr p1)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Not!\n");
        exit(1);
    }
    tmp->kind = is_Not;
    tmp->u.not_.expr_ = p1;
    return tmp;
}

/********************   EMul    ********************/

Expr make_EMul(Expr p1, MulOp p2, Expr p3)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EMul!\n");
        exit(1);
    }
    tmp->kind = is_EMul;
    tmp->u.emul_.expr_1 = p1;
    tmp->u.emul_.mulop_ = p2;
    tmp->u.emul_.expr_2 = p3;
    return tmp;
}

/********************   EAdd    ********************/

Expr make_EAdd(Expr p1, AddOp p2, Expr p3)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EAdd!\n");
        exit(1);
    }
    tmp->kind = is_EAdd;
    tmp->u.eadd_.expr_1 = p1;
    tmp->u.eadd_.addop_ = p2;
    tmp->u.eadd_.expr_2 = p3;
    return tmp;
}

/********************   ERel    ********************/

Expr make_ERel(Expr p1, RelOp p2, Expr p3)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ERel!\n");
        exit(1);
    }
    tmp->kind = is_ERel;
    tmp->u.erel_.expr_1 = p1;
    tmp->u.erel_.relop_ = p2;
    tmp->u.erel_.expr_2 = p3;
    return tmp;
}

/********************   EAnd    ********************/

Expr make_EAnd(Expr p1, Expr p2)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EAnd!\n");
        exit(1);
    }
    tmp->kind = is_EAnd;
    tmp->u.eand_.expr_1 = p1;
    tmp->u.eand_.expr_2 = p2;
    return tmp;
}

/********************   EOr    ********************/

Expr make_EOr(Expr p1, Expr p2)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EOr!\n");
        exit(1);
    }
    tmp->kind = is_EOr;
    tmp->u.eor_.expr_1 = p1;
    tmp->u.eor_.expr_2 = p2;
    return tmp;
}

/********************   ListExpr    ********************/

ListExpr make_ListExpr(Expr p1, ListExpr p2)
{
    ListExpr tmp = (ListExpr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListExpr!\n");
        exit(1);
    }
    tmp->expr_ = p1;
    tmp->listexpr_ = p2;
    return tmp;
}

/********************   Plus    ********************/

AddOp make_Plus()
{
    AddOp tmp = (AddOp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Plus!\n");
        exit(1);
    }
    tmp->kind = is_Plus;
    return tmp;
}

/********************   Minus    ********************/

AddOp make_Minus()
{
    AddOp tmp = (AddOp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Minus!\n");
        exit(1);
    }
    tmp->kind = is_Minus;
    return tmp;
}

/********************   Times    ********************/

MulOp make_Times()
{
    MulOp tmp = (MulOp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Times!\n");
        exit(1);
    }
    tmp->kind = is_Times;
    return tmp;
}

/********************   Div    ********************/

MulOp make_Div()
{
    MulOp tmp = (MulOp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Div!\n");
        exit(1);
    }
    tmp->kind = is_Div;
    return tmp;
}

/********************   Mod    ********************/

MulOp make_Mod()
{
    MulOp tmp = (MulOp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Mod!\n");
        exit(1);
    }
    tmp->kind = is_Mod;
    return tmp;
}

/********************   LTH    ********************/

RelOp make_LTH()
{
    RelOp tmp = (RelOp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LTH!\n");
        exit(1);
    }
    tmp->kind = is_LTH;
    return tmp;
}

/********************   LE    ********************/

RelOp make_LE()
{
    RelOp tmp = (RelOp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LE!\n");
        exit(1);
    }
    tmp->kind = is_LE;
    return tmp;
}

/********************   GTH    ********************/

RelOp make_GTH()
{
    RelOp tmp = (RelOp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating GTH!\n");
        exit(1);
    }
    tmp->kind = is_GTH;
    return tmp;
}

/********************   GE    ********************/

RelOp make_GE()
{
    RelOp tmp = (RelOp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating GE!\n");
        exit(1);
    }
    tmp->kind = is_GE;
    return tmp;
}

/********************   EQU    ********************/

RelOp make_EQU()
{
    RelOp tmp = (RelOp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EQU!\n");
        exit(1);
    }
    tmp->kind = is_EQU;
    return tmp;
}

/********************   NE    ********************/

RelOp make_NE()
{
    RelOp tmp = (RelOp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating NE!\n");
        exit(1);
    }
    tmp->kind = is_NE;
    return tmp;
}

/***************************   Cloning   ******************************/

Prog clone_Prog(Prog p)
{
  switch(p->kind)
  {
  case is_Program:
    return make_Program (clone_ListTopDef(p->u.program_.listtopdef_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Prog!\n");
    exit(1);
  }
}

TopDef clone_TopDef(TopDef p)
{
  switch(p->kind)
  {
  case is_FnDef:
    return make_FnDef
      ( clone_Type(p->u.fndef_.type_)
      , strdup(p->u.fndef_.ident_)
      , clone_ListArg(p->u.fndef_.listarg_)
      , clone_Blk(p->u.fndef_.blk_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning TopDef!\n");
    exit(1);
  }
}

ListTopDef clone_ListTopDef(ListTopDef listtopdef)
{
  if (listtopdef)
  {
    /* clone of non-empty list */
    return make_ListTopDef
      ( clone_TopDef(listtopdef->topdef_)
      , clone_ListTopDef(listtopdef->listtopdef_)
      );
  }
  else return NULL; /* clone of empty list */
}

Arg clone_Arg(Arg p)
{
  switch(p->kind)
  {
  case is_Argument:
    return make_Argument
      ( clone_Type(p->u.argument_.type_)
      , strdup(p->u.argument_.ident_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Arg!\n");
    exit(1);
  }
}

ListArg clone_ListArg(ListArg listarg)
{
  if (listarg)
  {
    /* clone of non-empty list */
    return make_ListArg
      ( clone_Arg(listarg->arg_)
      , clone_ListArg(listarg->listarg_)
      );
  }
  else return NULL; /* clone of empty list */
}

Blk clone_Blk(Blk p)
{
  switch(p->kind)
  {
  case is_Block:
    return make_Block (clone_ListStmt(p->u.block_.liststmt_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Blk!\n");
    exit(1);
  }
}

ListStmt clone_ListStmt(ListStmt liststmt)
{
  if (liststmt)
  {
    /* clone of non-empty list */
    return make_ListStmt
      ( clone_Stmt(liststmt->stmt_)
      , clone_ListStmt(liststmt->liststmt_)
      );
  }
  else return NULL; /* clone of empty list */
}

Stmt clone_Stmt(Stmt p)
{
  switch(p->kind)
  {
  case is_Empty:
    return make_Empty ();

  case is_BStmt:
    return make_BStmt (clone_Blk(p->u.bstmt_.blk_));

  case is_Decl:
    return make_Decl
      ( clone_Type(p->u.decl_.type_)
      , clone_ListItem(p->u.decl_.listitem_)
      );

  case is_Ass:
    return make_Ass
      ( strdup(p->u.ass_.ident_)
      , clone_Expr(p->u.ass_.expr_)
      );

  case is_Incr:
    return make_Incr (strdup(p->u.incr_.ident_));

  case is_Decr:
    return make_Decr (strdup(p->u.decr_.ident_));

  case is_Ret:
    return make_Ret (clone_Expr(p->u.ret_.expr_));

  case is_VRet:
    return make_VRet ();

  case is_Cond:
    return make_Cond
      ( clone_Expr(p->u.cond_.expr_)
      , clone_Stmt(p->u.cond_.stmt_)
      );

  case is_CondElse:
    return make_CondElse
      ( clone_Expr(p->u.condelse_.expr_)
      , clone_Stmt(p->u.condelse_.stmt_1)
      , clone_Stmt(p->u.condelse_.stmt_2)
      );

  case is_While:
    return make_While
      ( clone_Expr(p->u.while_.expr_)
      , clone_Stmt(p->u.while_.stmt_)
      );

  case is_SExp:
    return make_SExp (clone_Expr(p->u.sexp_.expr_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Stmt!\n");
    exit(1);
  }
}

Item clone_Item(Item p)
{
  switch(p->kind)
  {
  case is_NoInit:
    return make_NoInit (strdup(p->u.noinit_.ident_));

  case is_Init:
    return make_Init
      ( strdup(p->u.init_.ident_)
      , clone_Expr(p->u.init_.expr_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Item!\n");
    exit(1);
  }
}

ListItem clone_ListItem(ListItem listitem)
{
  if (listitem)
  {
    /* clone of non-empty list */
    return make_ListItem
      ( clone_Item(listitem->item_)
      , clone_ListItem(listitem->listitem_)
      );
  }
  else return NULL; /* clone of empty list */
}

Type clone_Type(Type p)
{
  switch(p->kind)
  {
  case is_Int:
    return make_Int ();

  case is_Doub:
    return make_Doub ();

  case is_Bool:
    return make_Bool ();

  case is_Void:
    return make_Void ();

  case is_Fun:
    return make_Fun
      ( clone_Type(p->u.fun_.type_)
      , clone_ListType(p->u.fun_.listtype_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Type!\n");
    exit(1);
  }
}

ListType clone_ListType(ListType listtype)
{
  if (listtype)
  {
    /* clone of non-empty list */
    return make_ListType
      ( clone_Type(listtype->type_)
      , clone_ListType(listtype->listtype_)
      );
  }
  else return NULL; /* clone of empty list */
}

Expr clone_Expr(Expr p)
{
  switch(p->kind)
  {
  case is_EVar:
    return make_EVar (strdup(p->u.evar_.ident_));

  case is_ELitInt:
    return make_ELitInt (p->u.elitint_.integer_);

  case is_ELitDoub:
    return make_ELitDoub (p->u.elitdoub_.double_);

  case is_ELitTrue:
    return make_ELitTrue ();

  case is_ELitFalse:
    return make_ELitFalse ();

  case is_EApp:
    return make_EApp
      ( strdup(p->u.eapp_.ident_)
      , clone_ListExpr(p->u.eapp_.listexpr_)
      );

  case is_EString:
    return make_EString (strdup(p->u.estring_.string_));

  case is_Neg:
    return make_Neg (clone_Expr(p->u.neg_.expr_));

  case is_Not:
    return make_Not (clone_Expr(p->u.not_.expr_));

  case is_EMul:
    return make_EMul
      ( clone_Expr(p->u.emul_.expr_1)
      , clone_MulOp(p->u.emul_.mulop_)
      , clone_Expr(p->u.emul_.expr_2)
      );

  case is_EAdd:
    return make_EAdd
      ( clone_Expr(p->u.eadd_.expr_1)
      , clone_AddOp(p->u.eadd_.addop_)
      , clone_Expr(p->u.eadd_.expr_2)
      );

  case is_ERel:
    return make_ERel
      ( clone_Expr(p->u.erel_.expr_1)
      , clone_RelOp(p->u.erel_.relop_)
      , clone_Expr(p->u.erel_.expr_2)
      );

  case is_EAnd:
    return make_EAnd
      ( clone_Expr(p->u.eand_.expr_1)
      , clone_Expr(p->u.eand_.expr_2)
      );

  case is_EOr:
    return make_EOr
      ( clone_Expr(p->u.eor_.expr_1)
      , clone_Expr(p->u.eor_.expr_2)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Expr!\n");
    exit(1);
  }
}

ListExpr clone_ListExpr(ListExpr listexpr)
{
  if (listexpr)
  {
    /* clone of non-empty list */
    return make_ListExpr
      ( clone_Expr(listexpr->expr_)
      , clone_ListExpr(listexpr->listexpr_)
      );
  }
  else return NULL; /* clone of empty list */
}

AddOp clone_AddOp(AddOp p)
{
  switch(p->kind)
  {
  case is_Plus:
    return make_Plus ();

  case is_Minus:
    return make_Minus ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning AddOp!\n");
    exit(1);
  }
}

MulOp clone_MulOp(MulOp p)
{
  switch(p->kind)
  {
  case is_Times:
    return make_Times ();

  case is_Div:
    return make_Div ();

  case is_Mod:
    return make_Mod ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning MulOp!\n");
    exit(1);
  }
}

RelOp clone_RelOp(RelOp p)
{
  switch(p->kind)
  {
  case is_LTH:
    return make_LTH ();

  case is_LE:
    return make_LE ();

  case is_GTH:
    return make_GTH ();

  case is_GE:
    return make_GE ();

  case is_EQU:
    return make_EQU ();

  case is_NE:
    return make_NE ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning RelOp!\n");
    exit(1);
  }
}

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Prog(Prog p)
{
  switch(p->kind)
  {
  case is_Program:
    free_ListTopDef(p->u.program_.listtopdef_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Prog!\n");
    exit(1);
  }
  free(p);
}

void free_TopDef(TopDef p)
{
  switch(p->kind)
  {
  case is_FnDef:
    free_Type(p->u.fndef_.type_);
    free(p->u.fndef_.ident_);
    free_ListArg(p->u.fndef_.listarg_);
    free_Blk(p->u.fndef_.blk_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing TopDef!\n");
    exit(1);
  }
  free(p);
}

void free_ListTopDef(ListTopDef listtopdef)
{
  if (listtopdef)
  {
    free_TopDef(listtopdef->topdef_);
    free_ListTopDef(listtopdef->listtopdef_);
    free(listtopdef);
  }
}

void free_Arg(Arg p)
{
  switch(p->kind)
  {
  case is_Argument:
    free_Type(p->u.argument_.type_);
    free(p->u.argument_.ident_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Arg!\n");
    exit(1);
  }
  free(p);
}

void free_ListArg(ListArg listarg)
{
  if (listarg)
  {
    free_Arg(listarg->arg_);
    free_ListArg(listarg->listarg_);
    free(listarg);
  }
}

void free_Blk(Blk p)
{
  switch(p->kind)
  {
  case is_Block:
    free_ListStmt(p->u.block_.liststmt_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Blk!\n");
    exit(1);
  }
  free(p);
}

void free_ListStmt(ListStmt liststmt)
{
  if (liststmt)
  {
    free_Stmt(liststmt->stmt_);
    free_ListStmt(liststmt->liststmt_);
    free(liststmt);
  }
}

void free_Stmt(Stmt p)
{
  switch(p->kind)
  {
  case is_Empty:
    break;

  case is_BStmt:
    free_Blk(p->u.bstmt_.blk_);
    break;

  case is_Decl:
    free_Type(p->u.decl_.type_);
    free_ListItem(p->u.decl_.listitem_);
    break;

  case is_Ass:
    free(p->u.ass_.ident_);
    free_Expr(p->u.ass_.expr_);
    break;

  case is_Incr:
    free(p->u.incr_.ident_);
    break;

  case is_Decr:
    free(p->u.decr_.ident_);
    break;

  case is_Ret:
    free_Expr(p->u.ret_.expr_);
    break;

  case is_VRet:
    break;

  case is_Cond:
    free_Expr(p->u.cond_.expr_);
    free_Stmt(p->u.cond_.stmt_);
    break;

  case is_CondElse:
    free_Expr(p->u.condelse_.expr_);
    free_Stmt(p->u.condelse_.stmt_1);
    free_Stmt(p->u.condelse_.stmt_2);
    break;

  case is_While:
    free_Expr(p->u.while_.expr_);
    free_Stmt(p->u.while_.stmt_);
    break;

  case is_SExp:
    free_Expr(p->u.sexp_.expr_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Stmt!\n");
    exit(1);
  }
  free(p);
}

void free_Item(Item p)
{
  switch(p->kind)
  {
  case is_NoInit:
    free(p->u.noinit_.ident_);
    break;

  case is_Init:
    free(p->u.init_.ident_);
    free_Expr(p->u.init_.expr_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Item!\n");
    exit(1);
  }
  free(p);
}

void free_ListItem(ListItem listitem)
{
  if (listitem)
  {
    free_Item(listitem->item_);
    free_ListItem(listitem->listitem_);
    free(listitem);
  }
}

void free_Type(Type p)
{
  switch(p->kind)
  {
  case is_Int:
    break;

  case is_Doub:
    break;

  case is_Bool:
    break;

  case is_Void:
    break;

  case is_Fun:
    free_Type(p->u.fun_.type_);
    free_ListType(p->u.fun_.listtype_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Type!\n");
    exit(1);
  }
  free(p);
}

void free_ListType(ListType listtype)
{
  if (listtype)
  {
    free_Type(listtype->type_);
    free_ListType(listtype->listtype_);
    free(listtype);
  }
}

void free_Expr(Expr p)
{
  switch(p->kind)
  {
  case is_EVar:
    free(p->u.evar_.ident_);
    break;

  case is_ELitInt:
    break;

  case is_ELitDoub:
    break;

  case is_ELitTrue:
    break;

  case is_ELitFalse:
    break;

  case is_EApp:
    free(p->u.eapp_.ident_);
    free_ListExpr(p->u.eapp_.listexpr_);
    break;

  case is_EString:
    free(p->u.estring_.string_);
    break;

  case is_Neg:
    free_Expr(p->u.neg_.expr_);
    break;

  case is_Not:
    free_Expr(p->u.not_.expr_);
    break;

  case is_EMul:
    free_Expr(p->u.emul_.expr_1);
    free_MulOp(p->u.emul_.mulop_);
    free_Expr(p->u.emul_.expr_2);
    break;

  case is_EAdd:
    free_Expr(p->u.eadd_.expr_1);
    free_AddOp(p->u.eadd_.addop_);
    free_Expr(p->u.eadd_.expr_2);
    break;

  case is_ERel:
    free_Expr(p->u.erel_.expr_1);
    free_RelOp(p->u.erel_.relop_);
    free_Expr(p->u.erel_.expr_2);
    break;

  case is_EAnd:
    free_Expr(p->u.eand_.expr_1);
    free_Expr(p->u.eand_.expr_2);
    break;

  case is_EOr:
    free_Expr(p->u.eor_.expr_1);
    free_Expr(p->u.eor_.expr_2);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Expr!\n");
    exit(1);
  }
  free(p);
}

void free_ListExpr(ListExpr listexpr)
{
  if (listexpr)
  {
    free_Expr(listexpr->expr_);
    free_ListExpr(listexpr->listexpr_);
    free(listexpr);
  }
}

void free_AddOp(AddOp p)
{
  switch(p->kind)
  {
  case is_Plus:
    break;

  case is_Minus:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing AddOp!\n");
    exit(1);
  }
  free(p);
}

void free_MulOp(MulOp p)
{
  switch(p->kind)
  {
  case is_Times:
    break;

  case is_Div:
    break;

  case is_Mod:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing MulOp!\n");
    exit(1);
  }
  free(p);
}

void free_RelOp(RelOp p)
{
  switch(p->kind)
  {
  case is_LTH:
    break;

  case is_LE:
    break;

  case is_GTH:
    break;

  case is_GE:
    break;

  case is_EQU:
    break;

  case is_NE:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RelOp!\n");
    exit(1);
  }
  free(p);
}

